%!PS-Adobe-2.0
%%Creator: dvips(k) 5.995 Copyright 2015 Radical Eye Software
%%Title: bs
%%CreationDate: Thu Mar  1 13:10:48 2018
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 255 203
%%DocumentFonts: NimbusRomNo9L-Medi NimbusRomNo9L-Regu CMMI9 CMR6
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -Pdownload35 -T
%+ 8.995000002980232cm,7.136562502980232cm bs -o
%+ /home/maciek/Desktop/masters_thesis/thesis/chapter2/img/bs.ps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2018.03.01:1310
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.23, 2014/07/31
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def

%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: CMR6
%!PS-AdobeFont-1.0: CMR6 003.002
%%Title: CMR6
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMR6.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMR6 known{/CMR6 findfont dup/UniqueID known{dup
/UniqueID get 5000789 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMR6 def
/FontBBox {-20 -250 1193 750 }readonly def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR6.) readonly def
/FullName (CMR6) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 49 /one put
dup 50 /two put
dup 51 /three put
dup 52 /four put
dup 53 /five put
dup 54 /six put
dup 55 /seven put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
E6AF364B0BFCAAD22D8D558C5C81A7D425A1629DD5182206742D1D082A12F078
0FD4F5F6D3129FCFFF1F4A912B0A7DEC8D33A57B5AE0328EF9D57ADDAC543273
C01924195A181D03F5054A93B71E5065F8D92FE23794D2DAE339BA29C1C6F656
1DEF13780383DAE38A868377CC7D396B2A05F341AEE0F8BD0A0191F51AD11A4D
2E927B848A1EF2BA15CFBE57A51E3AF07598275195C9613041F71C1AF39E61F9
EFD5F6512FBDA76E29DE6B508F62F5CF9F73F5288DF1C7B0B82C92D3B6358BAD
EC3CA20BDE55DAA7CC58004AA86B6CBF8C410D8287E88BF20588A39309C2B703
CED322F030AA6069869064486CA651DA054FF3F5E56534CA358B0829A6B954D8
9103436E6B06DAD1658BD4A95AB41343B01F5866FC87C4EDFC71F1477C98F8E1
1DCF27EF743FF90BF918AB8C4E5AC35841E2F745480E5EDE1C1DEAFAD8D0018D
2C1F1CFCAD9F6609859DEDFD1648A6CD23D8ABB80747F94899F17C8F3E6CA55A
E176F19CDFDAA0D7C920B3A72051A4745560AC81978C92459EEE5AFE85AB247A
32981139CBE352B248F4BE5F73503A084A3E91F05328EE521D9669E44E202584
5407E7846F9FEE3D54EA18FFB144BF2D6803BF65AE402034B3CDBB40DD24217A
3CE0E95E2717CACD603A958187C42B3558AA38D6B6390EEEDD396F96E6041FCF
6F8888221AFA87EAD79F46E0E32CAED91E6C8500879AB6E580C581E8C8CE9B68
2BB5EFE2604E8DCB2432D39D75EE556969F1B2FBDF6A4BC72D106AA7CF22C268
464027898B311613E06E1584707F262F71D9F49D2149306A88E02BC60BBD6BDB
EF41D90F19197BA9AEF32B5E63D5B9FF41B5602F9F786E76621DA54D574981AB
87A72081EA05D6C6BA940EFEBD0904EA4E77BBCE17E20B42E1722617E0F6EF32
F1ACDE9D758594E9C81049CCC10605A27C2A06872FBA9F159CB155609B496ADA
4886F478E44029B5E620DE8319E257697E93E1CDFD27D560E2E4D34507020E2C
D9FF06BFA14E056D81DF701FAC3ACE4BE6C098AE116E079F0044391EC1661F6E
7A93B9320BD7F91E8FD2E8EB3F5CAE997D5CDD35107A1D35302260D1499B8B65
39625B7925F97D917B66BAFEEA992873F07220714F192839948CEA080BDB9A03
77B9DD032273DDB5629CB28B5D8797EDEFDBC601823E038384C90C79012A7D96
8F27784DA15BACE21501C26E3AFA5DCCE81B52B0ABAF71A35D33103EA86F2415
A39A830D559C5C6CA7423945BD3DFA942B20A06D7A8D8671F9831DBB52907AB4
4E54776D29C6085CD9970B6DD21DD3EA8EB09C49CBEC6CDCEEB0BBB1B8827109
3BDE64DDA024D67F098D6C1998506DDFF7907ABAADA1C39C759C850E0C6F8E89
A392D1C9329ACFFA92D361218D75E115F70A47C53B73B356D703E9C499AAD098
AA9C8119EE9E9708A9EA3049E976FA19AD04210D5F6092C7903FD155113F3A3F
269B746560F70970AC9F8D09956E0E84DACE4112C4E7C7F6B3F0B63D26EFF95E
2B2E9699D16BC8AFC4AD9113AA3A974C9E82E877288CF71E9169D2DCC61AAAA6
C536E5604EF0716F6487292BBB677518504B52C63822BED3BD5FD14EB41EE6A8
AD4B6CF90D39F98E12A765B645CBA3E8552FB9A986390212CE119E7C3DD675AC
17BD006144BEC534DA2A860188619F17589008409C5A309CB83FBA70F6446B6E
2B56991B6A03B1DE10C621591CEE45BECA27C54BC8B4F1754A9E8F660812710E
117850E1BB6FD89BB13F8CE391C43DA89EA67E9C3E7A4697790EA26B0E4E2E80
DCA508873A7AFFC11B8C02EF86C2316E8D8B6BCEA37F81A3A87546705F070C3B
9D4D28C366CEBC1EE485B8E2357DBE46E86C87B9939DADA60888AA9F1B92FECC
CC1C198DDB594BB70A8FE690ECAC21A414BAC89BF019F34D2A130F485EAE35B7
2A10C67EA3A48A4D9734759CC93AD85C6A570500AE5AC9973FC76EFA06BF5DDC
26E20E28D16B50957EE01AF2653F8D860817967AA5A9BF9BF7ABCDA710E9F34F
4F0EBCC32B3C9C2971F6225D2DAA6A451366B83F32B2ACB83E746D365B2DE38D
C1AB7447FE7B37F9630E410E5D8F0ECE74DF46C538947B3A167AD9F3E4A7EB3D
60F5425AE75AC3A27D39311DA35696C3DC7282AF1532E7AECE63D13DDA0296A2
01487185FDF1875AEF55A36C17D6A8DD329279D229259463A2F05CB7A874374B
E2320E1F6CFECB9C1CE62FF468C29751ACD9754AF1EABE8E7696C2888914416E
235B6766F20FFBEFF285277B639A51EA2F2E30D207BC891B00F0436008F980E0
9EEE7FB375BB069B9E0BA11DA951A99D8E60B4F920A0495C247FA7DE904765AB
DB5C3B2D634757E43EDD6FAA4DB3C67F82D6853E1170F0B2D8CE496DD4E72B0D
28277BEF172F1402959F64527F9B640619F04416DDB9D05FB2ACD019CB9C119E
E544D24EA6DAC5C69785394EA50E6EC9AAA9E14B904EAF29A733C6D7942B63F4
85729686742F26DEF78DF0DA1CA7CEFBB684F4CAD99021A3B3D1FE03B9C5A4B1
BD04CAC89BB91B11952A2B17A61789BEE0C54B46C03FE9A1AE73D17CF94BA30A
237C29D414C3BCE8E3E2DDF83C0BD59DCB66C4D2C3DE73DA8378F3C6C8035D28
7464399857E57651A53E9C4AA68DFCA91B2376CF98AC5290FDB9BDAD9EF1604E
9B0A70EDDA1E564B6D2456E7BC722454ACA8C4950FDD44B6EB9AD01169A9F845
B06A0DDB7897C847A5B1F42258AECF3807AE936C8F52C3A7A0A85D68160AE442
FE81543DA6702D76AB6E8701F80DFC1D87C961E350D0E52AB2A298B9E5908600
7E14D2A87309043CBF13F69AEAAB1BC239DEA88EB5176624F6046664B1D2691F
FBB2071D3706F97DCCA355A6DCC4D09FD35DC078FBAAF672FFDECEC61050A120
10B5A96629041303FD01ACCC7686165DED6AA712FF8E5E85DE33C4E7D877C49C
6C469A90410BAF60BE65ECD91CDC2EE7AC0CA8BA7B53865F26092BFCAA0BCA77
B80DC51DAD09C93C8DD8E43502B4B68F3D5918C3492196292447732BA90F5AB4
9F5E1D634ADE1CCAAD028DE5EBA9535F6FC5908DBD2D643E0A7E059C8C386FDC
E72659C0033F535C0D7F6B98D0335552D0BF3C6E302B672A5EAADFCEF81912E3
8F54E6FB7EC2B325125159713D0AC50DEE3673B9B148643727E94C80971A2E73
5E1E13237BE69C84FC039DCE02ECE2668AFD047F21A61BB94A9F498C9FE5CDEA
B274B40728B6F6CA9B6C15BAAF92F465B0D7311B46545CBA90D874839443CCB9
3110F052EB247B24B45A3D2FA6FBC7EB2A4BEC2A5892914B3C5EA3F4F9B9DCBF
6F932D95700E045B49E4B1F2C9D2A42CF39CA2F5A2654E6E8E6E92473D28AACD
5E35C6705EA728F704F5996D286BED433F976AB7E018621A577AED7C0AC0A84E
A032FE1869F603E6F20386E3A190A30A21EA886249ECF8CDDE2C33D73BA8647A
3DCA7A8DD9E8EC8D9A415D126BA38B6771C489DFC419303EE9C1B83FBFB3A0B8
97D64F30E4BCBEC24DF603FF3BF541E00D5804B6B6543D3D2B661CC551D497A9
9DFFF535AF424B2F3150BB39AAE8CDB306AAD37767BA10BADB031DC2FAB16955
EE78342CCC0E8B5976BF98F215461A8C6F63EBE6E2F1A1104662DDE53388CB51
8B44F3534853B8095F3B746A2459C2EF800FB1EF7F235EBAA9731E3AB3BE4369
1D3636E3ADD5BDF0C34FA80E90D8A1DDE770943FD196E0A7C5F1FAF6970B34C6
4673AACA6B2B5C12B9608521AE736C1F4B97209B063D991300ED5AF3D7F27E76
68E0B858FD8BFF86581E2B9548C691E3E5D9EC4D39C9715CDE86C7D22223CCEB
8A38C776A30AF14912390A7546DBECECD7A687D4F08646E57A12C80DCA022B7A
33399761A50B8E0ABEFA1163EDEC3DFB5DA3248792EEEDD894872D4E6814B4C3
548BAFCDE0CABBCDB97EC6D1BA47F2E77CC1389BF19D73661749AC33F46A618E
A665A85776545BF9662F2179D7BFD604FA8EF4700591AF3AEC647E27B24B76F3
133F9198DC15C1AED830E737909E43EB91C334C44BA35810007A3888E33F5DA5
B3B2C35481C648AFE630CC3E08F77744E401B2934E407D1EC17ECE737606B076
F8DE8EF3344F57495EF49D11580D6FB28AE0B1422521B320843B13467501CAE2
3DB93D7BB779F73B6AA30050DA74BDBC3F8DBB30F32EAFD07734A151BB2BAED5
C9B1F790059339B64BB4146470F30928C9A49AE88906BD6FDB7431A4B50809CE
0F67ABA01CDCC2320B0B097187B9299E3D80CDD7BB5DD5BFA7B28D924C5633C5
45A23CCEE097C41C3759C1FA8DBA0DD95034BCA89BD23FAC18C70093F40FF2F8
0FAC5DD4835F2DFD40540E9A9E9FD951A8AF2CB766597DE00147B163BACFB7E6
EFDA4DED594F1C746D8B46A1145E0E4058F5917B3F21E9BEBDE745EE72CDCA64
FB31EF7A2E55265F32559480E2B6726D3DE26FFC97EB4E3160F117E890C4B2E5
8DF310E6A728ABA85540F571C024F8DD58E1D7827FE97CED5EB31547EBC36415
02B8C0E10B7E37D816F01D56A364B8552CBFAAA95BC4BDDCFDE91CE0EF005B4B
7AB56FFB47A093AEDF0DE1EA48FC8103CA3CA1470864D2693E360006D05668A8
AA422CCCED20DCEEBEA5CE0DA1EFB00FB93E922B18124FA11A88D0F6E0F719DA
57603DD5DA42E1C56C2FD9E5415AA199D4F334C151C1157E75C107FBBFCEB706
5F4EA47A29B54ED8CAEB8DDA2F53D2A703B95487619780A52DA1270011648A28
AA64338E04AA5B92C1EDF3D8DA34FA6D227A0325EA6F22E9B38B6338C657BB21
CD4C582DC04010330F62923F817E4EDC6E5C0E6500F2A975A8A95BAA30C4A134
BB31B5AC45A2E7F6E9CDFC810D41344C4F606049445F8E93D74271C1E29DF7CB
5459593BA28AECF64D903D3E4D77CF5C04B06DE44A41EE4D9FC769854503AC85
69E4A5106E84016DE3D59865D4AB30BD6C9E45C45DCB5408421CC50CD6179C85
34E55CC70FBD8FEFE9F1D5160664981716E3BC7F24B6F54E0323D9BC4B692971
24419EE62D8B0BA726E2B4294A9A76F328B8101DA29E78BD5C4AC383350FE196
4D42DB1653637D19530124858950C22F1E9CF5BC07D46B7A58CDE19CC88DCD2E
7FE4EEFD8AA6047E919823C8CAB2EF5274F45E861E6508CC11A8AA90AED2403A
B2BF1315C2157B3B50A3685205D93E40906EEE9DE5985405974BCE0B84BB37DB
080A45C5237B269B93C0A7CF294A18B45464A41F604C494CBEF829A381155CFD
71CEEA54CC39EEDB6DF58A9896246B09F95DC6BC40BA6916AAB5ED3D24F66154
3662F8978FC63DA9280FF7ADB09EA5BA79D3B66E0C88BEC1EDD78DA93839073A
A4D7B0E627000C4ABA76C47CCFEE92E319315333A5584A951E34C55412049C4A
A5569FE65A006F77B416E0530AB6A8E7AD6C72340AD4CE25937158FABB2153EA
281E1D840206F5DA38E00815E9081F81DAB9FAA8F4DAB305867AC84735DB4F52
A36129929BD2084A8EA37BB6889695204BF7290B68D5E722540BF8A276F8BB6D
451D582EE59D2FF03F6B97DDE05FA00C3D375D2D0AAC8FE298F85CC067B15481
48D70B6A0354C705715B891915FE8EA45244677B9FCE81E72D66177E309F3F83
F744B9EA9E55C3B30DEC6E5E03B3988FD526A82A5E8E1DC79127FC62B2FA7949
B3AD3148868DE22BD4B5708E32CEAAE6ADEED1F463EAB9692411E18F8D6BF391
126B2700B4CF3B59D02E3F8795130C96285A63FCD1E0F647ACB1D35E9C58BD01
1DD06BABA00CA4343BEBEDBE677E053E9732B33A7495DF51782A07DA07F5646C
770C957AD915CC70BA8E08BE7A1F4E6BA5BB9C603E38F6FB0A2578471C4D02F4
283069856D926B9076EC73AA39CEB0A061AFF1575C7093FDAC9F89C3DC06EA45
06F3C2A3BC9FF21128B10CB758DF0F099B459A5264A8C24C098110D2BA1A8532
8FAE146A91BA7D033F591AB1A94B8A6FE0FFB610F698D216D58B4EF6C87B1524
8037CBB7E23D8550A620341C6625A1A2ECE7CEE2598D66277F857231A36155E3
984F147783E9B93975AC38A29F2FBCF704C8A04AD84C3E04A12D2321FA56811A
5B6744813CCC187968C5C26BB8D3E6615A912FA5369C01CCF8C0DB790593B190
1A90CFB5339B8771F325C5FC448D36C7312B11A15A8635BAB59CF3CAD176131E
026F6E141B2619EF7F3048750CC9291397F141591EEC8B612D6656DD34DB54D6
DBDD303CED74BE76664E7DC86FCFEEF2001C9DBA56418FB61F589566A47AF36E
C94671C5E8939AF9F4D53C0DE7142B7B63C86AAFA65877EBBB48C64589AFB2CB
1280AC099FC48058855CBDEB6C2D2A0D092267996591DC3B5EC8252984E9B27D
2E9EDE8CD8303F0905DBFCAE497DE1B755B924452CDE11CF4F20893DD6FF7251
427F520FE00580DAF1703FD968E0F8ECCDE618E1EA5820EE6CFED97C78864EF6
26FAFEEE194A268F24249D44829AA360D731C34DC285501E966A959180718F72
6330E4CC060588A2F65AE64A720DCAA818D49D4440F5D0B6C1F6C3A107E12445
F1BED2D3FCBB87A9597F01C7332AA79143564056219BF87D4B907A04F77621AD
054935E883B2B137D3D1C4BC792E8335CA08B6D83227F35736C41312A0BB077A
60FC6488C5E02FD51A10AC113D4EF70038C649C1677B2204A77F2ECBE9B3C341
F4126BECBCA61E3F3801F9188A3775924A62D30FB096B440286FA655EBA00A74
9A4162904BEA07CE68EE76018346DEEE20839C9A2FF71179B58E1D4AB30856B5
F5D97295A097174467010B15D733AAC5813CAA633746B430B1AAF9F997FDAAFD
436844D1A56B8E25A89D2CC4BA6EE7ABD167818FD4F6C747E07B262C99EE2C35
323F0B471586CA50F54C6381B052B15B0C58C19DEA82C0CA29F00400B727419B
2379979CDCBFA966AD513FA903160C571C3BF1BA239540B11EF2371A3880837C
6D6CA2F374280CFA1586427AE975A2AEC34244874E4D441DBAC6CD1828841C91
069AA87FAE849C5DC7C9EC1B9876E59F3CCDF8BB23D939F5348D7486934BFB02
CC5A22541ED352616830A510DE7732E5D8F7E785BBD31C2BC9D348CE5632654D
2C1740F89D57FB2AA1FD8FA3304EA03F757BB8F498ED98E48485722E78D97B12
A05F3A28438084D1CF90AC4C3FFCD7B3365941C45E1E02CB13CA1E99F7FA1D00
1C9D489D5C95F019AB4CE89FA3B6604473DBD2CE8E278969E0A0FCBCE68C23F6
9381882443D3FC16966555FC222F3FC4B1207522201AB7A15A7A6F22CDC9D392
360BF4C95DAD35770E0AC7E5EFF015F2C74ED7391F40EC94B8D1C163B5DEE5B3
911A20C2625AD3B24BD94D2A42405E655DA47D3F94F882CA2F479437B4E0BE71
8AFA4482C6FB270F8D05B4599A01403DAAA90C01DF3AA7C2BC7E66AB6AA833AD
FB6E5EE13E45CC7CE7E200FBFE639F9CFFF5D08512C02764997FD28368969BFB
0876F236EF6189BE73AD827332DF1B2EADEAC0ED3B939CE5BC3CEC78975FC636
44FCBC2CCF4396AC7343EC62E0E4F3DFFA2B880BF31D93ADFE201BE9CCEC8BA5
0B9B919E05B851E0909968DA259EECC6AA0743F25247978CC09C28C4F878E29A
5070E4023BCE95FE0ACCCC01D0EE219FA8344E8F6D7D4347563BF8AC030B9097
41F24D4BC9494915A82EE9FD37FBB6A46BF077B728FB569B1258CEA5F51F36BE
4F4D0F890D782E44748CA3FE8C8A515998371D9C7D2311F192B4B7E7C68FC6EE
3F7136714C282A2570FE591F247A08319CE9EF1E43274E4E57166E31A2ECA506
85350DA31AA4C33C9687F5210BA225EA1007C444FBFA2126769767E47A967884
9F68589E4BAA9ED32A7A466DE35554C132810C68ABDAE536D9D884352F28EA02
8A555D2CE11F30598F44A65E2D86B43ECCBDEED9E4E5B5B7DCDA20EAA09D9FF7
422FC91F2201431A9E8FC624FF44D26C0100183D77BC7E6B1A6CFBD3FA8BABC1
AE4CB0FD382E26BE0A83169B46D91429DCB746A0326243E212F802AF6A56C709
6E70C6C7C0263765D340333B5CD8D1282FD5B0F5BD4D40DA12A5CF44075F33F9
BCC0B4C20EADE30D0ABB3562C00540200F10840375F980123041B13A105DF8C4
E3EAE855F2A4E445C86F4EF6D0005CF931DC49A20FC76F6236760CE0E9205832
74903F0247ADAB232F15F34D6AEFA50E1068B1C1FC32EC479D76E4039FC15D00
5E94F604210B7680AFBE26C83D0E51E7F521E1B559849F1B9A36866116621F31
05761D02EEFC5887C43344AA269D3D944B96143D421B257BFE78DCD134D7F757
90571F65D0A1B0B821253EBA59A1CE36445B769AF223D3165A817BD6DA6017A4
0C742250BFF3FC0AC0AAFB22A97661909A8DAAF4FA7012E1DF607BA2968D628F
D1A60C3CAA1B91F0EB56180FEA89F19038D4AA9BA851A736B948052994F674D6
303B1F8FE598FE1A2A7A49354C52F9AEB514352DEC6832B3706C426B4EB927F9
89E12CE28FB381C8E5C8D061E3DD8A9ECC3DF2D10D5384324E37079E6B44A547
15DDBD95916E56C3287B982CD581F19F6A0F1213232B701C5395C8E5854B78F6
A5E3153E04B0910B3B42393F92098D57E087F1A371CF02CF64124D20BC2D7B1E
54FCA37FA2BE7A729CCCDBC75BA0C36D3957951C0E511A3F7EB94EB8FE2BC454
DFEEC0D529BA6F64F4A1BD4319C7BC1DBDB3D37575F107A9115C5FABF4BDFB8E
24359353636AF3F591774DEDA5657CE7A69394F6C95D05E3C230760F86152EDB
2BAD31F8F8AE8B98547F6DCD51AEBCEE254910741E7A9290301CECA6F3189A55
F42EECE2E20C453A4020005B7B0CF05AFD98FBC4DB2898F27B8D7731CD5D795F
D063C7011DC6256C9924B62772995E2F1330DF68B5AD04951137E4713F83B574
D66B479B212268920E59A25F01A7DF48F34BDB357A7907BBB91A016F664E55F6
076EBD2028FB4095FDEFCD548B9A6302D3830841A8C8F07A95534671215AF76C
55FACFD7EDF2B3E53FF9F18E01FE8950ABAFAA52EC5F28B2169BCF031CB11348
15E1F026F7B16D4452411462C5F501727AA16B72939D8AAE89353434B1A80322
EE3E98C3167508075BC3D449A0BD85CF86B0023DF8444B0BCD5FEF62C99358B3
78DF26B7EDE423177400A8F77C445DFAB4E85BCABB496B642AD7CE25C44D4164
87B1E234906690CA0D67E59756C442F5E458553A503F136C04C82DB192EC4A42
124F282DF2C504C37B10E9EB80483AF839641D4847BE157DEF943B99E17A8B59
63903732AF619DED90190B70D6459DD29B08772C1FB4CDDA8F0754F04A722C05
644840865A23BD34AA25D36DFE19A72ACEBBB76C64D5EFC46A00553E7322FA3A
2F3379340A6D55B8FEF84D5867B44F6FD7FB436B2EFAE22C0900EEBE17C09EEF
F637EDA92CAF3FE07AF1DDC1382CDCD204E328C3DB86124DD15C773F8FFB33CC
C3A19C273319D2E1833AA301F8BCF8E1CC5C1137E95CAE8C12ADFB59DA8E2D59
5B7ED149D77584AB020F6F3EE92602057F08D27FE5053260DE82D1487364626E
C14635E4B5A31FD4E42D19F9216F8203F5A98D9C50E77CD4A9016D38E1AEC0DE
AE52D1D9781CC6A93B0A1683E5962754DA5D45E9814A7B6A0F83A55C4A33CBE1
56645328461ACFB938A5B850E265B223D02D4724619B9772275FA027CA585A20
914196F34E24EAADED799DDFB43CE6BC8FF3CEB32E9D25EC54A26439D9A0F78D
F593DE378383F1BCE710703DC4A859B2EF5B6CB2423B249E9BAB3D06ACA0E1E7
9470743735CCF742E6A9CFC7AA91491E69497B3A5F2BD08BE92814058192DC86
DB33F089658F117AD4A85E768177EDFF013D642DD77B06291D2363F83BB24854
3A74DD9EAA73CF2EBE055F688F7C5B10CA28E3A964
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: CMMI9
%!PS-AdobeFont-1.0: CMMI9 003.002
%%Title: CMMI9
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name CMMI9.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/CMMI9 known{/CMMI9 findfont dup/UniqueID known{dup
/UniqueID get 5087384 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /CMMI9 def
/FontBBox {-29 -250 1075 750 }readonly def
/PaintType 0 def
/FontInfo 10 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMMI9.) readonly def
/FullName (CMMI9) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/ascent 750 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 119 /w put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE3C05EF98F858322DCEA45E0874C5
45D25FE192539D9CDA4BAA46D9C431465E6ABF4E4271F89EDED7F37BE4B31FB4
7934F62D1F46E8671F6290D6FFF601D4937BF71C22D60FB800A15796421E3AA7
72C500501D8B10C0093F6467C553250F7C27B2C3D893772614A846374A85BC4E
BEC0B0A89C4C161C3956ECE25274B962C854E535F418279FE26D8F83E38C5C89
974E9A224B3CBEF90A9277AF10E0C7CAC8DC11C41DC18B814A7682E5F0248674
11453BC81C443407AF41AF8A831A85A700CFC65E2181BCBFBD07FC5A8862A8DB
7E2B90C16137614CDAFB584A32E50C0935109679E31306B8BDD29F1756946A67
7A7C2D9BA6FAB9B20A424AA0E6F4BA64C2801C2FB5A1156CBEED0ACB95F697B8
BC2A6E6AA7EB1F9FD8E3C9B1A16697EE1F0E7400421A7765AB218FC837A49365
82DC6B2C877A7DA84A81E6126EE96DB25C17A207D3020A045DCDAA064360DFFC
E3CD50E21ED239D2A6450D04F879A26443ADEB6A20ACC504989876476C7D1A74
91564FEA1F4CC2C8C8FDF666DB537F315AE1886C73CB5B00E67E7B398A6C018E
540EAEE98BB8136C4F044EDD63C33431D2CF9740F051DF365A4045D9D8782112
7BB5D494D9235BA98CF2F30CB119F5A904C32AD04C960C43FC1F5FD8DA7D90D8
93AFB59F3FF4F796481AE2A7548F948FECFC6C127C4D3F159B08F206AE8C296D
EE470DB2F879EA79475E029D22D7A8535C09A18689DB0609CC233E5199C02756
972CC9C94D9FCE264DEE5D75C8D651E4E2D1189AD9588CB815722BB5EE3C379A
6F31C2E6AE1AE4CCEB29766190AFA20EA937114978752189F1A9F42B39483149
796FCFA123BA9CCD1D9BE28289660BCAE16C40B5B504058D55CFCBFB4F4E3D94
DDBF39F157E63946534DA81C018B1C01B9F10DDB55E0A5C2B3985ED1977C039B
D6755EA42CD09E27751E159C30B93F376DBE61CD3AED34BA36A768F232EB3B80
E3E6B77C4A48D408217818E398B83D995AB6BC871F20991DF57313D6EB0C793D
0F28088EBDB7F38DAF7E01AAB3476EC24D7BB38A9889A7D3038D930FF4289B83
F54A7BE1E2D98A3822098D2E4D067A0D400C20C0B2B4BBD74C13ED1B827490F9
ECF48F8C3994C1C5AAC9CF783BFA4F307528F51EAB55F961808A42ED53F00C97
72A432EAEDCFCFB622389BDA707B6ACC9433B065CF29EBFE93AD14B8ECD5F47F
F073F11822C49B8BE924CDFA6348C3A75E9BB9BF3F31C41716B34794B28CDAC9
4DB8B087E180A9B3B17680F73D9C12C8D86A922C948093629F5D7F542ED882A1
692F4F6696865E53E3E2DD43B2D5E8C989CFAA5CA5C4C5999045E170BDE9921C
BACD6F2863F5553EAB2BA2D4A9034729EC0C4201DE90DA89B0A27C5A5C974109
4E37BFB3F46B3A506169FB0C68E1CAFC844419A8D261A1FD86A3BB78E33D5FB1
CFC687A5975987CE45155E5FDFAF0CC5FD5568CB1C26212F92E88255F0549F59
41B33125946DE43436BEC00804063FBF03EC796E3361B1C852EC3038D107F80A
9198968265D5488B26D7670B22C2D75EDFFD1B7B4AAFA36DFD94640C9D0E2D20
5BCA18683EFB91834A3939AB8EB60E2F09655BE003582634C52770DA9668C292
2E02929D812EE2B0CC65F020064AD5BDAC5F5693B30508F40ED8E20E87149BD5
8DD41AFF83FD1944804017DC5A04512E593549FFFAE501131CE2FDB65EFD0B8B
33809CBAEE411B3941C241550B9C30DD28088708F1C0CC3125CBEDCD985EAD28
03313741F67DB5744A87B381147D5BA70AE1145C27F794854628D87D6C1ECCA1
749E3465B950175D3C3F40E344297BD92D3190041A4392033A79BEAEAABB8DBE
CC14E39612F43721CFAE6F79074429221CA588AA2501DE520A464DE157A03AFE
3C082FAE7628FC0C57FFC61D0330AE6332D20FDBB09BF36848FE05E782D6379F
64F9C82C45402481B0A35989027F9756BF5A79DA2D96E10F39167ADB4305578F
90B509B6891338FA1D67DCFD61804AA6621526B2EE4769589A2646581712AC05
DA6E98D16494F07D612743058F54FEE516BD89A8EC3E03F9D7F905175D3412C8
F7329077FD6EB25213F3CAC94BA0C3363B759401B6EF7548C7D709F3241D030D
4EB46A1AE81863C412BDDAEA6084C37143A4C5E41BC646315B1CD09F934186CF
49D1D8239E363A435307030BD79536B50B723A39DD763DB539F24A10DDA12BD4
E467339D2D6DB177D6FC539FA77D2DE4118EBAC161E928749F7C753ADEF86117
58619F1155C563DF2E11ACA8347908B98113AED58FCD0394150EEC94B7F986EE
88BF7171D208D8F1774B1DD478F0C2958AE372D257E7EDF0F6B5D6059CC4D5D3
B00FCBD2E9CBE79235B9A5A3E943CC27AABB58728C95C7DBD4F4A1F8A4DA99AE
7377B0CC0BFBD454794398AE0D5F7281771FFE87B25A819F36E692286A42D776
01794A43CA9BB30FB8FFDAAF014F909A369E34C2F6C75B7D4EB9DB0580E33F46
19654443AFF8384B95600B86FF8E41FEFD032355626D60C7507C058EF832DF41
194B48A36F11082D1DCF4723E21401E0C7447AABFAB4639B26E3D2730E348F55
53EBFF39CDD03E06E2FA5FB379603C879EDB7E1A10F89695C9C47DEEE52BE0A3
F446F187AB9D7E93E6F9387F21129034F36DF40605D28FD526AF82CA9D232BE4
412567F06B38ECCD496EF40A7B243E46C9FEBA4F1BF4B1ECA029C5EC239353D6
C0B100BF7E7DB33BD1277DE104F15AA19F37340A777741AD1AD693BC76DA48CC
C6F83CD84591ECFEE375979972B0FAC4C10B625E4BFB261B9FFFA83C31DA0108
4FFB6377466E9739E0EB64424BD9FC7239C7DD834EC6788A0F97FE714AF92831
E1BA36A8A9E24739F1DC82DC26CC3CE28C210AA7C569B19E1784D663A0CA4E81
AFF43E86D6F5F63778847700072CEB77A4EB946DC1F23DBC00BCE773203F76DF
00F0B085F31420672974DDC642D885E95BA6BBE43E1CA8ABF464D9881CDECC7A
E98E31B9754C9B72A8BD5CF6D4D214DBC3BA7A0CDF6635953F5AC1E7639C4A91
C7AECE4C75CA3389C348F656FC2CC96C84C85A926237B6504DB51937C9CFCDAC
B75C31ED570D180757884E27757783DB2D5F35ECC48C496CDA342D49AA947BF8
2FDAD2F19DFE8CD1C76A8FA08F33681F3E12E229D7DAB45BE3A3F258B5ED4980
F15340CF20D965252843E026803E8AEE736EC41CCA82167401977AB719AA2F50
0B791EEAA82027B3C712D2EB9D14BF8F94FBDE2227609BCAC41EC08DE2BAC023
28352F913F7DF08D4E1C66E83F764578B22B4EB7191E852B91ADCCB1BCFDB1F4
E63DFD152E86FA9DE9BC8908130EFDE29CC4401339C05B5B9764CF8EFF14951A
C6C13AF979546996BF22F2B96D3D585B90CD27DADEC78914DA48432C6ACBDD42
20EF583FD41F2F6D6D10C3DF7DD077304B5940BB0462656E306CBD91EB9B756B
7014B1884A36201EC582FC9345C386043DD2818FC301EF78791C1D7854F8FACE
5DE9801DE9F59D5B4271E003AB897B2EF49501589D681D59CFFD9B03F722EEF4
74ABD29997515DA3591496B62666744EA76DCA45504F8075C0652D6779DBEAE4
90430C2945FBD60AD53B51DDBEFC7ED703C418B4B244C8FFA5A3C1B7600C5A55
3EBDB93C16AC191C3A28EB2279BD3F0D67C826BC6A73D3C0AD02262368AB4621
98A1605F2887BC5880E1AF2780330E0FD01D7CAACBB0F008A42C427F38236066
54799594E515B289044BAC4DADF8B3686B4372C5110201221FDA923F131E07E7
93C44BAD406838BA4D1C277EF74098B8C0EDC41EEDD58C195D7DFF5FEDBF96FC
19CEBC6C3006DD2CBF76916B4298BB915663C2F61AFD7747E03A03BD7280197A
9DA590E3D081C6F53DBF94E8D6FDDDD910A70AB18A0F6D48A590FFAB314D6CFD
E3FB20C1F3C91063F00726A2C13A3D48323F9854839405E5A29D66A43E6E2B84
A8B3765F1D817071D4D6FF42BC785C2D11AB2B9452F141696CE19C6AFB9777DB
107D6E22D8CC6C26440BC48248AD8805C4329D46BF433741CB519B21663392DA
5DC7FC9BF37E5BC396BFADD7263D09F6B4D69594AB386B7BDFCF3BACB97A0E08
22013E716E642592A20136CF9CFD61D4E515D80E06A4CB4FC9D9B916C93CEA95
B83B98C48CF36C1D02291D4F5C0419338D64E33C90C90EDD2BA3B96D70FAFE0D
403A060CFF448D3E28A9B1E3916018465E86095BAAB4706CF7ED350D7C554789
D7F4FE5F180767DE8739259E68CF142040BE1E2E8C6152DE3417C1FAEA7584B6
20781DC4A9796431EE713DAC4E713C839D7A4FDC8AB6BFEFFE767AFD8B67FDA6
943AD387E5D3BCB09039ADB64ECC2BE2620C6EC269E708DD06C311F450099E33
AF46AEC644222E7DC4DBB9371EE12CFBC4F9B27AB46AD1DA96CE006E1DF8291F
A550A93026CBFFC1087B134EC6EA76F5E109CDA58FF47338A0039A786A575F70
B8A03A4F9C8D07A4C856C77D9BCC8E3EAA740172D0C2D0A15BA35C9E5717D7FA
2691774DDE730BB9D7C70D7AE103DB8D35F3728470C76EBA0E670634E1A0BA84
2FA102BAD7271DF2680D86A4CA6FC353869987700E5E3FD778165456033D624F
E9B3E80EBF431ACC934AA0357E824B8AD73E222B510DE8445C55C07C8E5DE46D
E478F832BDDECAF2EBB11941DCF84CCD887043FAED9AA90D12BC8CA9A0C8D94F
8D3BF1F80B14B6CAE6BB1C6AA405AA64BB94D5A82CFEA548BA070796A02F9642
87326D066101435AB9EB40BA9EA9E61B363F5F5E3B924369796E8B78DE3414A4
2B79C6A13ECB2F34E6299658D07D2B3DEF3D4383CE009A927F0EF5C196652842
D96B857AB5E905201E7E8BA21A5EBED1FC6863BA9A1A6E5390407F75055E2EEC
512FBDB3E82CEA13663F1A1944DA072C765D8CED06AB461470C5723BDC1271D4
4D1D049D3EB131743F1EC9A6ADDAA038ACA2C41D139DC6A84EC3C61AC7F1E559
6155CC2F49171F6E07CF56D721D9728E87FC7DCBCAC46455A3694C765FE807E9
9CBC2D304AF37E0F28CCB22F239541B53A4D24D09C662559267467EA487BD33A
0BEFD4899B581D20582930703A868655C31BE935364CA6A95FBCB22CB714C040
9718824DFE97929D0482430726CCB5A5307957DD2432A9B6271E849148DEB76B
FAA290FF6D0B18DC5B76407852E81C105EC6CFAB0F620C6DC9DA555A33C167B1
430A8BC338BFC7D75B7099CC906AD923FA107C74D3FBB719D77A4E5A685FF9D8
56424EE4AA074434B809D894ED50F6A60A035C5223EA25DD8983B9B34210DABE
718D7B2BEB293FF1B63CFB1CBDAFC69552963D90F5E3FF533A3FDBB626E9FAA3
F3C119E5E01C7BFF832A033C3515BF049E29558B1DAD652F2888E339E67D15AE
95F9BD14E3253DFE9072B24C0E7E85025B71096AF51C86AECB2921126A43156B
EC812B32B1164BD9B2B947D503C015616DBF2024F5C8CB3236C1DCA653D661FE
6B1C19A22D272A176B7F1B7F9E67AF40DB0EFD4940E58B2A050249CA4E55CAF7
6ACFD84FB46FEF952D18552B3972D79D808B4C263B8C7E1BB647A2D03E102867
630D5C3F2C917F765A4F6FB8106BA6A9D0093E27A4CB6049C2371287D94B5111
6E7020776EBD744C6C920464BBBC0AC206033E8240017F8CCB112596ECD7CAFA
89950CF43FD87ACA750C03A778A37FBCE9C82C2F5ABB135BB02DA8E8C0D24475
3BEA9D79372D0022FF1ABD378C151417DBC69FE5C9CA38D23A3900E34BF924A2
90777ACDC37930B67DD44A2E76DDBD9B89598D5F626BFD325A978D277265DA47
38CFAF16E7FF1946E15F41CA73F7B4B02E5AE8FC4C37B115BC567E4EEEFEFC34
EC8974B1465AE57759EDDA28DD38A9210871D35D331AE1BE6097C3EC21C770C9
B25D040B2ECCC3AEB1EA1BF99E0C2C0F192C13BB9152CFCF75332E03F9CEC376
9B8C285A35F53655BE38713E09AE34BA2DA9C06FA42A6FD2D00CBF2AFD2BADB9
1571629C65DA38A431710CF5B01FCA68E8B8569922FBC3F9B64A5509B6F677AF
1B97E91FFFEB6308AB68AC58F9BA43DB5E764021E75B56170EB44C2C0A7DB86C
62B8982256D3621EBE3DB3994DBF5C5A14CF34B4AF3BD5697F8E3203085DE9D5
84B0598169760B925463E93DC87CE70AF4C2DF0F4287D2F2069847BCCF7A37A2
AD451D5ACE4DBCCB2E14D5DF38B226952E7446BF87BEC736EF3D5AE793304618
D66D3299AB9F9CA1D13F134FAEDF36750046E27706C7CBD8E0877BB6276E5196
BC2A355D109C0253644918E1CC11B717DE6FBDA201E769812752888CD66268F6
4ACF4A9449378F9F9923D584BA1B51F33663BE7A306887BC14A37E3C5A4654E6
531D6EB63DE3946BD8BA95CFB037991174F36D61D842071E6625605CAA350A24
FE551025D10871FE0E2599A63900C8520EF4911C53A03897C8BEE152451708E2
43FCF4E700C583A5E8DBCC03BF9CAB864DBD19E1760945DEA0EC0BA38BEA8256
D3A8D4F70F6685A99C6BD2BA8B412A26C002D76138CFCC7DF6802931E5D97BA6
0151F6A4C572235B4196B22B7B2D14B32886DF0D2CA8A277ABAAC53B63F64CE4
E4C088192AAB674497E8AF81961359C389B51F4A257373D907C615030BFBEF53
DBD99058FD06E352450B658478C10454AC8FC0232B70D5CB916981978053E358
99D322A07294748BA427FFD1E45C909171017B52B7C742FD77A8560852D819DD
8DD53211A14D7B2FD11E42941722FD3985D627FDAF87EB57326A0D290B5077D1
8A4230BEB40523A8565F95E0D44F036A571DB698EDD9D94FEC9512369E5E5E73
A3CA5C142617944F4F99C0697ED088ACAC007FCE06E5A6EDE7D0E03A3399DCE5
362271BC31533866BA79FD1FB3F608B22CCD4111FFB1BA35D920A23AD157C6B3
C3DAE11069D5E46DEDA7158C6478D8B8C0D9DC237CDF0CC6633911673C43FB79
E4F9B7F27495201E5ADE66255BC2CBE9D9F237DECB62A19D62CB41A1C92432D2
07F0629E913A71B3F1AAF8B8C5AC66D3C8605A48F8913E39C859E163DB1DBC8F
0ACFEE80A40B6172032E95A76B752B873FB4DF23CF3A655AF1A1B88C8DC156C6
190DE72973950565454C0A188A33395FD3D529A88F2B578356DE8EBBC12F04C4
5B899F667D9E6F3A4EC6DD8DE71FD4C2E2B6D56823EE4E0526679D71FF1B868D
F261489F06F97B010CCBE640E2F57BA3DC3332B329F7958394BA9777D833AB50
005E8E9232547104065ACE33396772B0E0BD66D2C6CC54DEDD071E444D8C95F8
6F88B31E20FDB80F77C83151B7E25BD3736B4F9BDC52EE78C41E9475E5A6D94C
D348AB42F5E36B4F167D29EBDFBD43B03F77EB296B06A36880FF17D412E77EA9
F2E7C25FD05E16BEC6732681EA21AC3FF6893B93FC09316A370CDDB86D9E6087
F6042C3F9ECD742778389170F5F041329782FB9F9702F7533E51F355F71825AE
2BF4F8FE50D413AC9A20C41B42537FDBE8DDC5A5C793D3760C1EE13716068752
F0AF10812250BEDFB4D7133FD58F4587BACD572505C84A7D3802D27443175FE0
0D89C3398B55176D8642AFBAB5CBCDFD6220C8488564B4306D74A58CD2921AAD
73CF803C754DAC2F30A5324886E273064FA51781D5BC596BFEDDCE3982EA1AA2
62CA7BAA1B16C6EBB99B2AAC4E6C9CEFB3D10F19987045C4918DB239E6E63D79
5F44B9D097118D081153AFF96E5EB39CBFBB99A3BE30909F614869031358EB98
F07A97EA78AE50375941B2474DB46AF3305F2B208D45921F93743A6CB8AC584F
6BEBE25ECAADD5A789EF60C9F54446687E7B030DA3E5243189F02BA46BFD28B7
DC14822E136AC7E40CE20458DDBF356488045C95907363864CD6943643BF0109
EE027A3091C11EA392EA91320EBFEA3B857370AD8EB86D73F035A476F7058222
E8CDE78CA1AA9EA69A8AA6EBFF3E67324C567B914134DE042D6F8F18A9373107
536E8D90189917D343F5299024239E2EC1D2D177D82DC8E344A7CF2AC71AEC18
36F139E7A4EB59A67192BCA9ED0EB25DE13032F6FEAFC3B1F4FC81BB0EDC41DF
B9EB92618667C59EA499B788CD26C2137D70F1B0AF793AF5AD0D0941F2E746E3
F5A7F0288BC1EE11E982EAAE763CA422D72FBBC0D754AD58FBF92629DC8866A0
431213513744DB48E52EFC89C83FEB082588E4F30D7DA77BB598E51CAE7E4900
5CD570C914EFBA426BAFF7A56FC775ECF5BE13F2C42E51EF96784E5201C0B64C
074AC229FF0C46BDBE15D89D826CB5889D4C92533C221F94C7708A8AC9CE7EC9
C7BE60226A9043ACC6E57FFFDC036280EFD5D6D61CF570B62361832311FD36C0
5A396BFA6B98DF371372306016FC18A97277808BAF219C688559263A19A47A2F
C4B1DC3F8DBAFD69842358642C807D954075C0FBBD17DA9B844D1CE58AAF051A
69CF16AC06AB2263A3E93881C666ABA9905B75E3661EF62321EA612594F33E86
F4277406EE124E1F83BEACA8663A06D354868F2A1CA4FBF67CA2EB5F29457BFD
38D107D26D993829B481578E58829305273A95CAC40934CB8EA32EA3771F425E
18C3E503750E9972383388F6D27C30E4F3699AC0296BB4505BEDEF421111B4D1
03EAD3B467BB1CC04B7B89031F37CAD74D086905342DC891A674F06D9FD1E4D6
E087F2ECA0D435651DCA437B19AE47ECEAD7E6FDDE480302EECFCEFDE9106148
77FB44A2CB543FD99AD0C69ECD332147F29B
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: NimbusRomNo9L-Regu
%!PS-AdobeFont-1.0: NimbusRomNo9L-Regu 1.05
%%CreationDate: Wed Dec 22 1999
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% (URW)++,Copyright 1999 by (URW)++ Design & Development
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (1.05) readonly def
/Notice ((URW)++,Copyright 1999 by (URW)++ Design & Development. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development) readonly def
/FullName (Nimbus Roman No9 L Regular) readonly def
/FamilyName (Nimbus Roman No9 L) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0.0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /NimbusRomNo9L-Regu def
/PaintType 0 def
/WMode 0 def
/FontBBox {-168 -281 1000 924} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AB7B8E152A40E590419249F2E4
C36159F8E54B532468E36965A38646781AB0B7F6A3E851FD10CAA49ADFC1E546
2FD2EC6150DC6E19523050F6148348A561AD8D2E2721EFF8A570CB33460A745B
926C889304C09753C2D78FB0CA95DC6DE5B8C524752C83601E7E9F73DF660674
F05AD83A166DA9BE89F22FEABD4B2665960F6FB5BC32928E1230C212E5D69CEE
0B3311A1738A11747AE263106916D8E95F25B25B4BC6AFB03B79ABB95DDA518B
41A49458111D2A1433C043627EF9460D324FFE22935F4F6DA88B8B91AE95B34E
08408A34EC8EAC3F65B6AE3E3E2524867EE9D29068F81E4372F4470BEEB4D6BE
EE4DF956BECC0CB77F8490117B22B2FB75C938ED0A5E208D88BC38B2AB8B9CFB
F1D53084B6F43DF336481ECA0AA2D5317BC83FC0E1D4DB01D0B7707EEF217E94
A7F985102DED27D8E8B009F7EF6DB91B91E78BFAE7BD688E10B3DC9AC77CDEE8
47AA4DC8EC78241E593D26EC7A60696151A2AE5325D736E99E01BDCBDE69579F
92EEEC224B6757EEDC64A75455BB665DF42A0E4CE7B99BF3E7D66F8FFC8C13F9
D7A1FF7A9D5FF7AC43396779F11C9B008C33A2043D48B61B88B03104B1425F09
675B559CA4302C001EE80D2B739CC0FD1023BF4F1FF9C01E892E59CCA7C26011
B8E0B6D29CC29FC72792FDA5E7D5D88EF98F9DBA960C96534C399C54865EAB86
0FA2E0D6C7C44B553EAC1574D55E7970744D4792FFFBDCE6FB4365BDBC2965BB
2E9EDAD9E0EBF0B620DB415AD98297F5AE83D9C710436657E74D26E83957C745
89834337035A7501803947F6880B70E56A3A404C62D57B849D28804CBE0F5884
435A0E12DCC9BA414ABB732BFBAE237001F557DEA5E972BA0838A3C7C9EB75AA
4A050DA0A529BDFFBF9011C360564FD17A02C18860AF6B86EFD4E2C125686C9A
5E114E95C71FC89A5DE9C589BFE5AC0480CFF716345265D2435EDAE67CFC4801
5BC08E7A48D683ACDB91E05F469C0C8919D73A5D07A1CCB173E30E76680ACB09
02A40A3E11916198BD69F1A26E88330F50692D0D5917E99E7A01B327413E24AA
E98EA484E45897E6AE4D6997B6E8BBF61C9406E916D56985CB2BD297E8ACFC6E
CF2D2281AD84696B7C6CB584BD85CC20BA14ADD3BC3E25DB91124C0ACF22E902
3CFBF04CC40DE331991E9075D22AB5EE0E849B340050E6C417C664A782D05549
DB2EF572F193B1C12B4635C2B358747046DE585E9EEC4FBBE9CE6AE8532B2CD4
101F1E68B19CC8756AD1987CCFF2302525BA8389489E8AD29C974C5A18DA8F05
5671EBB8954C3A90EE42B2AFCC9D2F52165A0DF06D6A365FB88544455AA87281
8C323EC616CEC04738328542CDE8B0B5BF7C93F1B7E133F3A0518EF8DE086451
334163D1D60B17DA2A733E28DB0DFF1CC06FCE2B0B6A6F13323FAE6EAAC2E140
289A9902475E6CE9C732FFD0344F1C8772BE74E0705D0904CE66DDE2A0FBDFFA
E7A5D02207DB3B8714CCD8900F91C87934A7E178004DDA6D91FC094A714F4A8B
27AB4787F38B78A41FDB756A5F2415403C8F7A99A825C8A6F37CE009152A0248
5C3A78D7E3649E597C9A8068828C2B964EB7976BDB0BA9541C3D806BFA4FB77C
5EBDD889F9D80B15A0764CB951D16524B621E0A4FA9D6F6F4C619646B14A25BB
40D57C2B958845B8788B60E408B6BD71BFC42CC17B0608329D093E1F9990481A
E419883FF01BB562BF7A8CD1C6CD40BBB35A568667C04C5536562FFF26C1CB5F
D8E91869E0A83A55638A573D81F89504703150AD673C8CF43B1D23ED27CD5E59
41D6326BFD00F8E2C46B4C975ACACB7A8A5A254A978CA100066CDE17ED245D82
EBD6D8A0E6E054359B579CD2E0064E5832E860F937F033783A442321927A1A8C
787CD363A398058AD4ED21814D5132E07D93C5A9B27F2B44615B72C93110F533
73C50E14657ED09FB27A350233112B0A339366B7373CE058456E0E1786B34190
AC06A6ED10305E09ADDC767335712B4542DA438ED25EAD7F8BAB714D9B09F67A
90A5D28CC03757EAEE1C2196A14A4D6F646BAFEB7C19098C9E2A518918864738
2BE1B7891A84B9697E22FC61EE575562634B306672481FC77B5C6D7843D0CD59
C28E408A938804609B43776382C4389362AEA7FE4E03637B459A9AA31F595844
55FCA7617F2744370D43F5E2B9EE586D4E652D8A9517FFF5A8476EEC6D910485
6CDC71475E026D4C49D6F39100C86650A81C81847C0A16ABBA26B43440202E2A
9DDAC2DEDACD4B602ECB5A4CCCC075DBE603115CBA55BEEEBC718DF9816B69E1
9F73240349FD6342DAC7FF8A4BC90C6D9D5DBBBD6D42C75DDCC9095D7288271E
FE70A060DE73CBF059D2A80F151376F29E7CF1C96C9B9A5A894D7135DA75FA89
17601EA0CA8E192532476CD8EA1F5AF507CB853A32E8C35D5DB595D29361F825
3C26C37E09B4F87056EDD8C90876FB49A7C535BD506B2B226033A297EA3C8C9C
8B22EEB2CCC0066047253D42A77CF299453536D0E8CAD7C149A4AD8CD668493D
56F9848C7306E4DCA49805DD0DB9AB8CB35411E0817DEEED6B71E0D8AE10672F
59120E41320CE40CC56A5CABF22911A5F4A26FA5575E8E701EE8E445A579C9B5
EAA32C83D7D667D4808E9FC8F28213E5C3BDE4B435014829F1A0EA4CF0DD9598
A9036B749049229902B646FE133A2934FCB329953875F95C55EF8381B2F5168D
B2F3CD2024702BE0D79C81597D49BF022A2D851A47A2D64D7E8535ED02349884
DE2E55FFF208D6D731C47D617B5049538CED34E669A162E422B331A3242DF909
2976AD6D1B60895C289260E878ACE4F6553610240BA008A5D130F81567439AF7
18D3B7B02416DF5DECABA1FF61BA03BAA86B2ADFE7375B3EB93E04B4CB55101E
E81AA3E236F3B7FE950BC177A79C37F73B3AF2DD6D4E50A9FA8A768897946C66
6A0E691A83EC2C2B435FD290256F341ECE72F40947889ED65C11C14D990FD43E
22D8715545CD2BB8B613752CCBAD725D4A308ECECEE20AD96760E54657977391
E1B0C80C93F83A5E7723EDAE0FF4F344E74E132F623CBD8080AE47CA260B30F4
8CC15BB0CAE225AD578B3065C7DFF00758317C484D3AF62F9770308E8BD5E665
904E4490521A22298C3968FEAFCB14E56184EAEB21881F8FF9EB522471CE2A7D
0756614E564EAD81BDC76197D97A9A7F928108402DF39C62DA2EAE8BCAF81DBF
DDD48EBC32FB261682CFE36CAEF0433CFF3E13DF36D75C6FD4E789466852BDAB
AADD6B9E6E1B71655C46DE29A1353D128AC01DDB12947B1E56023418758E8F66
1626CFD73B90688BAFC791B2E6517A4E1BA2F39AF2E91A226D4929EE7C9DC63E
A8F9780763E889B13FB2B8C91D7732019B86C11D799B79F33BB09CB6771F637A
C8211F81404A39FDB273B64ED685BB2F05E6532BB84FA0FE2301C72CDB2334AE
6D267A009BD0A11514B42257428D0E9DA501524CD28C00303A6879F7154DA276
1B130F6E136712C538944F5C60E652EF743F21C5CBFD7B8E466D657A804EEF16
19902225A0732B430F78C742585727C12F16E867F7B692C959CDB7A45A98B5C3
1FC9AABE7ECAA5701B0D2575AF8A8596254E942F891B0605B75435B3075BA7DA
5F6434B8BD5415078A582ECC2D33E5E2C360DA0DF1B2213E29FA209ADFE55F00
5150264A443188410BCA5B8C6B62994CE17EC9E5650576F30B9927A3F8A737D0
8ABF6F60D401622AF1D1FE947C4AEDC2E8216277AD1C0F91117094316383F169
B80FBB9083F99B6ED3B3AA4E45402ABC97E92F07A85E2C93AB0EB509DA1A7D74
A76DAE7C2F389F7870B9B4200D72175BCBDEBEC5838B58331978769574D066CF
54ED5E3235C56B73B03A67E7C577911EC5D845FC0352DC31C19D8C279B914149
70B7BBFDDD78563E1D4ECD4DD8B065AD1B683FE6FEB1DB4D034DB5A047B8D574
769188C0635CCC80324E85925D3ECC13992AAE7B6DE358244C29C9830DEC5247
49A6C5C0F20571C577ED03D63028C4ED17A90E1FBEF6E3778DE10A910F346C4E
D33D753A65BD918A9DB9077118A042EB52EB7800276E7502DC0119737DDBB167
F06DC088C78888EEBB74C92AC1A5A55C4F7B414A39B0EEA406FA1978FAAAC954
3651AF7899B7891EFECCDCBF04B78F1FE8179FA6618A09DF50749E55267744E0
46627E381FF09727EFEBB52E569DB68B706C2E033240C86703DA69FF071CADB9
68AC5964C15A4B043AE552E8DCE8D6FE9FD5337AB3A481B5B76ACD2D9DC0427E
46177C447F6AA378AB1E9AAA88112BDC3067605E119D5DEED4875C207B1CB79D
D44D6F226637CEF83EAE696FD1FC4A3F9F8D2751636084BEC4B5F7164360FFCE
6ACE16C863A79EE1A39BFF6CDD7F41682859F8A6A02CFE7365C3C7D4D17A9FEB
72914C6A148781A11207ADFE8155A93B5E44B0EB854995ACF03148E2D9CFB4F6
54B12158EE165BA4D5A7B9D149C8F588C22B4E5ABB2E6CAC6E9C5AC6C265B14E
1BB6C46CB4B61A1CAEECA093BE87347543F9AF5162C0119A2E0AC5EEAC153DB1
03486F397F4EE3BCFF001ADD45AFF4718AC799E6347F7DB3BDB9353045FF81C1
885F8BFC6C181397A30E58D2DFF67B383025DEBA49FD4F11749B97F3036387CD
ACA818404E80FE34639833E2972AA063B9C5500FF2F234B79DC65856CA9A6F6C
BF21F0385C4010FC280EAB291808EA2EB1505DF76ED45CEAEC0BDCC168B924C8
61433B8BBEF911422ABDEBFF8C2CE91B5B27FE97E1D595E787E96359EE9D23C7
EFB646AF5D119EB97ECCF4099E01BE746CD9270154A29A76AE72D1586EB0E10B
DDDACE6F288711EF040ED36292B5571B13D28E585CA2C81E20639F0DA069B554
78D6C884CC8A93D55990B01110D3FBD341AD62184EDEA071AD0580BC14CA70AE
A97FF4B704F7641BC26CC85B1B342DE6B5E3E38467519B96E7A56FECEF893D1A
4642805F7AC940DF416E626B66428A89D6B762918F635DD650F404BA14C3E9D3
D5937698573BFAC6434A1BD30E3554F65A2BDBE89B6F6BB32B219D9AD46FF967
E51859F4A455482B979DBDE13544B856AD10C8E459C7E2B55BE2EB8B973B283C
9FE104E141F00F814CA935835B40EC27B7ED3E03770C23A83FC926E4E49C0E80
7750BE4A783198354DC5C16AA511B556E660B7C64A4E0862D035E6AC70E1B1B5
F02E969ADF6CDE36D67CDA9CAB90AFCC44A5C176DDF5EF780A02C3598E6D3D67
A98CE6C6AE3A34049A9CEFE18F3D1D6F4A30F183A66BCD53F824F8E62EF37C8A
F2501EA578451EA348374C62A562584A6CF6A6AE7B54A2FF603C50253AAD2CD6
9E5FC43926740167FAF9069FB9AEA836703D9ED604D473BB187D364C2CF7E2E5
57F67ADB15CD6D689260A161FA5DE6B93298C56F9DE29DFCAC798130C0CE5C49
E1C5FB11EEEDDDEBB01BA78335CFAFB9E1AB382D2E56E5EFFB1B3DB7826016F6
90C7CF1CD8CF6D0E1335A4058E25F6D9619B9967E93A79C65F1EDC5CC0D8A503
C01A1425D5A6527C369899672E47DA7CB4ABD9B410BEF6473FB4126192FE50C0
4AA0FCEB4503D281F5443F84BE6EC4ECAF1BDF49C019B657C6F245DF5577981A
C9E03429E8F98BE81598BDEBFE3979CC6D60881693C4CD52D8B52B10AE95CBAA
B2029D04CAE8D50493D3E66113A3D86383746099603F69F7476B6B9B58C792C6
777C88C9461E5EC00E9091708D48C6DA8A47E6E52B28A9470121BB6EF26312D7
F141AA42E8F07A2A5FA6A8C0465CF3B6CCE6804182D495D6C22A6BE76EDC3630
005730241F1DC7448C1719C88FE99BCB73F7DEA427FBFCDF4F00E92B919650F0
0D4F0240AD2B6D0FF2710FF55BC9FDD3B638E33FD00255BBA271A4EF003AFF09
4650AE0168143FA202582854830860E09994BE8DB3CCA399DDE7FB996B0841CE
90D7BB6633CB481DC110FC14AAB8E9264F5EEC2C64C25B2CE086713E396437D3
7A135783DB2AA4FF32507B371B3770BC1D57AB4D4A064B68570DF5F0EC49B29E
A2F4594C145972130E2D9D95F7E82180B7FD734A6D76DB8B39E24D22F1CA51A8
C3D3064255B5BCFD3A47DEE3F38A3DAD94210C55C149FD938DAFB5FDE3E3992D
7396B421F161A4A856647C3240A0258D87B420D0AB55040AE154F64ADE51166E
B2F7D5B8A843A4F76970F76BDCD12D7454FCDD3DA3ABCB8D17BB4FF779B615A4
FF989CA255AF0ADB1903F7ACF4EC2B60997E3D78E889547C1D8DABE1F7BC638B
F1EA608924E30A31098C15B39A865C8850753C954F67EFF5F7A4A018BC6BBD66
70E65C0310A4FECC7367179779EE2B03F403A1FD4DDDE31B55D4AFBF7235CE72
9E47DE78D6AA46DF2753ECFCF0A21A73E8A189967DBF2F6C66C3BC6E9D7EAA57
7D05C3127559F7A15079F847A91220BFB289D6071350643A91D8F4C884C4FCFF
3A13F308BC6AAAB62D3C3E3AC3D816667133D08C4252B328D6CA4C5EFE2BC6C3
6A76D97D1DFB1DF34213FC4F30676791BC413195BBA1E96FEC4F26000B652B87
370A60A28D3D50BA4D85943328001B9E8FB902DEB084FA4170CF621599E3A952
8343BFBB41433632A244D2CE10DDA45FF84DB78BEB165BD93B5F797EF349A0EB
76D952CD4025CF5E256746E4004879603EFA6E08301838526123BF0B008837ED
8F6D3BD3CE232F889C961E9D8CC4B91FE9FBEC2A0825FD452C1F234950E92941
25882B26E3AB47EB44F60BFDFCBF512A6D1BD78A25D2E08B992F75AD0C1B399E
B34E9679035008A0EC4A735865A9C8700CE3441A82415E7DB04FDA19607EDB09
F9C68ED419677F27CDE9F19DCDFC2F1E545E69298001940C26B58845A31FB389
257B8BC394F8EFAC2AAFC238DCFCD3AD9664DF472729CFCB417511F98DD53C98
C07BBC1AFE19165F88BBCEB6B1B18E7063D774894508FCB96590716ECDF4F00F
DB901393FE87AC239CCA9402F6D05CA2472D1E50FB66E417E6349633E62FED3D
B7903ADD8141E65ED3CDED086B2AACEA7D3C6E12CD2A46F5111DA954A9862B95
5AE83D0AB3E72592E7FE113DEEB0067FA4F6C0E00ECFCCC56EB26560F2022073
178BBF8F893D2BE4540E04CCD2C30304544987AAA187D088C0572ECAE3BB30E8
68D735FEDAEA34CABB64F009C68F7E47A814EA0DB63DB758CBE08DB74668F780
654D5D2C4218A91449E0BF524974DC1FF69F6995E80DB9B35A88FAAA33AF4DBF
52AB2B2BFEFA3D03903B2AE15B9483740F2AAAFC47AF6A24F83C6D3A903EEB09
E48873CF9998177ADBE77748287874E7DB593866FB52EB9EF208B1E4610BF294
CE1BC740EC90A0764E9027D61CE5938B121C4FE9CE8337F7EBF5AF326230B80C
ED913EB6E69DEF0B183F07F541869E3AE9CC7B6087C9F370E2431E28C3293A58
0C6F70C1B6E7AF8E11BA4798C1DD2EB7D4F9620BC7D6EF0D0D40D6063A7272A9
D341BEC0C11FCE9480BCD7C9B83CF61D7087A1AF7E0663AF1C2FF053C1379F40
3A95412E4EB6B7D7B2A078E26A1657650D50CB35C74BDB9F2B2613CD296ABC2B
3A537DBC042E3BA32D6008B89A4CA1D4B6294F2A0C317554A76DED2743FC862C
057F377F39699B92FA8FEB6436F2AAD02710777083723CA45D3F5CC1170476B1
7BCDA45C640C583F16DA207028080516F2DCF43283BCA59F109E9740BCDE6BC5
813EA8EE676B35CBD378C1E449853FA9B624AF0A0311F9C9B8C4FC1211315D0D
6501C3C9CCE8B3BD32EBCAA12C5A7FE6F4075A6139FBC02F70479BF7DDBF596C
1246B60F2ADC7D8AA6B427927D8E8727C9D2161B0A61FB7A6B40CE507111F734
2FC452F09CECAF8912601015D5823FECF7D1975BA6C3B277282B71420727E7D0
8DB2886927917D9C1451E0CA738565A1A432B6D784CEE09F107A22A0F4CE3DC8
D56DDBFC110D96A4FDD7A55063A321EE7E538C4C60CCB0AA4CE5F70A908313E8
3EE1FB4E3367DE4DB71312CBB85ADD21D5A1FC163D84083720D9B5CEB6E03087
7EB3C7D60A3791362A72BF4F755BC4B0A996C1197BCC1B5DA763F62F5AD902A7
5EABF9B761FAEBAED987E0B9F196398364675257F65BE268F2B3B4875CF45D78
9F4C7520B11492D5F22FF7F527439FD6B64BF03A46E1F9D2513B2F4067D539AD
8F2345B2F405589F1513CA0901EAF267D24F99D24AC9D54CA821FE5F62683652
CF5D1E3DA8EEC5B53ADE9DAA8FC6B5350CB1C56BB44AA55D261D7D6B2EC501DD
38FA4DA38FD38C134DE8C2FA22F72716B5F934387FDE0B873650024181365017
B8F255B3758BE3CD48FD8F9FE4EA91817F824F6F3D1672936E595E75AE4F8276
FB8F386C5F2A8351F5020C79F76C3812366022541C5FAB4740A9FD02D865AC28
6129FB53FCA1E9CF50E263E50AD7D19E4D760ED2610A6F74ED859E85D7AA5405
8135C6365DB6AA428AC1AF66BB5807FE288AA6CCF6C7C7E6111B92133CC1490D
70C0E83B6D78E418C6142016898E28BDBB4E975D99697D88EC5151E7249D4F27
27E44AB6F5977D1D2471B5E4EE660878375EC6517F05D0F0C8B8EA7B18F9CF57
990518773C0261F3A55F821A3C88C9B990413E7A3E7E9C83917559839353C5C2
8AAE29A4247B2A4515DBDD8338E088FEA24499138153E3CB357D04804BAB10C4
864A01837D732C4853307A34E0FE2038249EF0F82F6DEE1EE7C4D0F1FA9391D6
29A1273FBB1CCC0ABA726760393022962A50A18C92C001D59BE3CEB9A1494984
E8A2415820B376353BFE406E91C38B04C158F82F6DD053AF5835FE22A79095E4
331EB96E7C47A977CFDC3FAB4F0E0575301CDA60558F65241DEE49409C10DB07
153312FFF77B19F9F1C64AE9850B3680A200EFA867B0A922D00371AE41210AA7
A444428DD055DD35D91A1DD46538032D7553154FFDDD3322A2B0FA0C1AB82116
D999DBF4C21BC78B3498FEDD429B1B1B8550F2219E7EF9CC64983779F4FDBA6E
4F0859AFD74E72167A3D3BD86F381ED2C4806E9A93C7CF4E83F0FBC6C4BFEFE1
78BCAF292623E93AE28EACB1D8A253BDAC2DA7BBE8EC827B9FA2A1C49D43C95A
5D96C622B04FCDDB40B675F081053377364DEC21CFC84FFBA306FC5E40690E46
4D46673BC84C902C0F9466730074CEF8E44EA7FC0D28FF3E8AD35CF856DCBB33
5A3EDE0435F57FCCEE637518F5812EB351B65581525A22A12051DAA179BB6B4B
E6A66885E271B68EE25C4B160D6162D791D759C9B9E9CCFFB119B21C90975F74
DD87DD74B1BB7C4564FB54FC6C71558E4C1A9D0B93E9AB53EC14C9B4191E9716
0B441CE68DA94A34B11825621D3C95364BA46737C2A61A3B8F58CD63014155DB
034B8818891D1901D385F268E06414083A4D17B0334995C155E8F0AF51FF07C9
66B61B01180333ECCD5B3FE94019A9662177BD5BE0524DDB01771DD0AE22AD50
955595FCEA65516D97F1F463EDD0A9C0118790E5780C0AC27A05B64034572AE1
B2B9A234F394EB619D4FD9EFEF43C4933AE29C10EB06135D9789ED82968EE23E
725CABF73E2B93140DCD2558B542AD8CFDA1E202D4FFF604BDFF02BCC180716C
F825DB774EFD3AE4D7F6B695E7A7A4ED77EE14DB5563C4DC2999A5D1A7DF5B0F
F04C42C7A0919190FA1F9CE52AF793A4937CFC9E9ACC236CE307310AA50B88FA
BBFDE0C27786E8D91344CEE59EE871F14A55D1C8385CD1FCEC32D12729662421
089CBDE14721864F29CED3AC2E4537274E5102564EE586F97C1FDE8E7BCE0164
5BCA2E036E02FDC6366BA2ABACB9AD1760964ADA8436744E78820401628C3994
C49C54859DB5FC6D3B9BCE6711ED4F4A7876F5BDB495EFF99DE8DE53C20F8C9B
7320F7F93D55DA358A464174F505F0F6CFF798BDB71C084BCCF70EAAF9F8C37D
31577E8C0D68A4B89535FF0E9A26D8FF7AF6E0E6E181AB858313D2F697474CBE
5641E71306FA3F81E297E7AEA353F541E65ED3CDED086B20B84F1B494BD3185D
E85223A77EB43DD46D01E050A7DF7673BD5D654BC8C65B809321300215973091
13785B754D6205126E4CDCC23EB4C431FC6C1DBBF79938BA648C75F10698EFCD
EEEDA99C75ACDF7262119E30EB552A688977266B06B756BACEB5FCD36A0F1535
36DAD78AFF2BE3A7AF1258A15ED5674C3AAAC4CAA8344432F60E76B21446FFEA
FF4A66DCCA05B42F9B762FF8905BAA1B6A8C716A7D8FD300019AA3460355CAA2
5060BA156183BDCC461B0F13569A540BFD5B314A919A5FED3AD97222765ED6AD
DC4B61BD20023FF06A5F3B1A51AE4850C6FDD6BDFA7BEC1ABD547CBDB6BCC20B
BBB289486F6C7E238FB635793AC884E8B42640338CADF35AFFC8E11C3503F324
F3766415C09493D47417EEEBD2CC07BF989CEC3EC8E59399964B982FC858089B
AED969370631951C63F5EDAD944367B899A3688FC658392703ECA95499FA9D3E
3C4B669B27CCDD74EADDD86CF9DF579B3D72349C643725A385D4729F23E8541A
ED00A23BA814323DA321910FE1EC00F965FBDC29D062680850BCC4690FB31AFB
3808A450BF7F1F3334AAA50B56D05D29B98C9D152D6C0DC98C51590C83A50F07
33AB3264B55E03AC61818DCDDD6A2AC664D97F3F1DDF55DBD314B20F9215B085
F4E2BAC9E70397CB304C0755B802DD31E8954584CC933FC342E5C6941CD3C293
274ED2C5CAD0C162EBF98632D63BC149DDC2CF15FF99555E34634B52F0B8B83E
EF5CCA51B26402F46D0ED4F0A5D956F69B4B2ECB5B720B5CEA5B78ED3B27D873
52069A414D615BA09E156C449C172832EA2CE7D575135087EDA7E5D330B26397
072281E35A0824873074C825AFE8B34C146C28976425CD45C0A5A419F924ED50
F8441FD8880CE8CCA2E488C1E2FD1CDDF9E109FFA5ACD8889C77D9A9C9278690
B8210B0FEC54D67EC0B609504BAC6C3E11E2AAEB2F131DE3C8A7025F58153AC5
6ABC499641CD5067C15F9BD19C9513779373B27D34B280B335AD163B23A91CD1
07445215DE3D6D1627FE8397E4272C994F5E4C7017215351B015358E5379BC1D
273358A84614972FEC966A23B451EFDFA251E9C42F9978FA4DBA32C2A2EB8857
6FF8256F35B7C21002955ACC280F484B9BEA6E32CA8E9FE11C9FAB70CB7B4AE7
6E9B61FC79BE898D48A7E98A78F95D433DEFC6EF499E2787DBDA3668D6AA66DD
E6E15D08C97C04DCA33030F18747D323DCF0709066CD5DE6FE9A71EFA0DC404E
F0EF26B8CAC6EDE0CBCF1AC4B243B4D10E470D392A24CC40A39D739BBE60A899
BA7AA3087B29A835840B2F8FA919FD6190D998A586D0D221041311B1B76CFA2C
5484B1EBFE30EE6EEF7C0BFF8712885144012F5E93035A6016EBFAB335645427
BB19C7470FC9738A501F5180C288DFEF0B52FA19CCD1CD563D45AB9CC63ECF9F
58CAADBC625BACD72597EE12209E30CB61CB12975C83C4905CC640335575C69A
9E28456EAD64116546DDE018763207772914F2181D9DD620E3BFB64A66F40D77
EA4806E3A57C3AD60331EDD81061F5734B2CC811D310055B4E9B6A8983D2951F
D6D86FE533C8875E3B8676B19B327EEA2728E743B312BC537AD6A18744E61BAD
C69CC451012F7311768CA8A6C8FBED9E5CAE7D9274F5BB9962163602A8298579
6CC34929C9A5F0E7B1DBA99EC3F0028F905185C2567166165BF75291EF6E741C
950D2755871B72E38980283BD02488289998B271B5EF170CBF2CDCE50EAFB9A3
DED5415955006D84F3D55FF383A41BC5E82B0619797C44CD60A409853113DBF3
7098560D22D87EF351F2B64044B078B9FE3788D799C08C008D12296C82C23974
52E370086183167A48211D9ED82F28162EADAA82B55CB95F177BDAAE52C269EB
58B1C7C9D9D8EE9BDFB33C0A65193A0EDA054CECFBBBDEF10990E56259343EC1
6977069E198EE55ADD6BA8E251542D45B438059C264AACD708D6E5106A44E56C
EFC2A1D01380352A05347EA14F4AF735BD975652DF965B810B0E09D55309DDAF
6CE1459E4132768858246B1463158512B43E623A1349807723EA6450ADDA6128
2B1A9024BB429AD556341061CA3F2B4BFF69E4B48C2B8DCFC0CFB0A834E277A9
BF158601F28133CA0C01F737DCE78778AEF0AA6C4274CE5E96325C12D96031AC
CAD6DF251207F1854F5CE3EB154AF02F1E71612FCC79636ACD551041B516F581
D2EA4FCE1892426A1A86E9150D3A8D8A41DF3293B1F35836BDA20DF9AECCF490
A67332565F4212F5F7235A497AC3845A29899BC7CF93D9E997842C48E8E9BBD2
62EB4E30B3E0BF9BB0BD63D5DFD66F262A21B96433B56C802AFF5F4342C12332
0C1A2BA366CEF7369949BBEF5774427D761C51E96FF61F6EB70B035437F5EF01
E9AC5C2ED25F6258FDCC96DB1D1663D170CD9AFB587A9EBC1BDE263CEE006EB8
65ED7A2DF7AA76C43571E105A6BBFE6EF0A7B85C3C4B8AC1AB5BD1F6064C1CAB
D21985DC0DAB47CA0EBC76718791B050181BDB459CDB3B5A214A04BBC607C7DA
7F5105D5A12F8F73013AD9CCB7B260E5187123FC29F4B6A1D087CEE4B00B9845
372C13E0393CD49A990DD986EA5AE8951DD7C5CE7FC31944650C0874441A7CBF
B62915401B4814DC6A4378BA2EA5FA01EAF0E78EE64A77C3C5F73EC8B921538B
7481B361E2699706E40880DCA456E1B85458CBF05D950163F4E8F349820782BC
5563379CC564E395E58FE917B8B20874F8B0A4C43243EC3D22FD0D29B68632AC
827CD868D325819E7E827187BEC2DCF1A53181A332FB9D0E183C3EC17CBDE2C8
D16A62D9BE43ADC8755F19861069AB6D081207BCC0FEB8F0A45C5CCEA36F20D7
7EB10DB48159C8100384094C9E2D49932C64B9674813D58660A036BA7C0DCF76
2E1AD3F9F350E7AC316D
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: NimbusRomNo9L-Medi
%!PS-AdobeFont-1.0: NimbusRomNo9L-Medi 1.05
%%CreationDate: Wed Dec 22 1999
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% (URW)++,Copyright 1999 by (URW)++ Design & Development
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (1.05) readonly def
/Notice ((URW)++,Copyright 1999 by (URW)++ Design & Development. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development) readonly def
/FullName (Nimbus Roman No9 L Medium) readonly def
/FamilyName (Nimbus Roman No9 L) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0.0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /NimbusRomNo9L-Medi def
/PaintType 0 def
/WMode 0 def
/FontBBox {-168 -341 1000 960} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AB7B8E178732AD0E135F772215
EA7EB7EA7641D31502E1BB9661E7B0E875AEE90400138F2AAF4A8686C73EAA44
E5CAB467770A3D12E9807BAC97B24A8EFB0E276760F4F51EC7123C43BC6F8DCF
9A2F496A9172813FB461FD870763306B45670653A9780FF409B734CFA74C12CD
150B03344295918C4ED893FB620A9499404B83C71152BF2F2DBF769000D116D5
EE264C016EE3E1241018F59544CCE53E5AEC124CF6C59A4D7D7D511ECC9AFD49
6608ADDD237358D7CF8B4D1C5BD1158CDF2D6469D9BD6E6D9762ECF34D1C3C27
5F69900E0D12AF9B21F153585742E999870BEE3DFF6309CD82968EBB40D9C269
CD4306654AAB6734151132DE4194072485FD082FBB6DFCB3FDFF9E1FC88D9483
8AA64B5825293978C70C9EC095B18352BFDC34B4BE9C939384E3281BCC6B1808
A6B61EC4E47BB6AC14B105FFA7ED6AE99A1CA0B360D1A5C24E0FBB55C66F5811
A5CD0625654654651979A8C4C3612054181CD300CD42D1D9CAAA589118D6C7CD
5EA8A9A0C639D5539430D40318F4B739DA281ABF2BE2765D44F45B218BB192E1
9EFBDDF7777E8730FA7DC0651BCD5D68EB743C51D9CED55403021D45F77CAB5E
7E892B3D1F875DA86C030A2387487DBAC8795749E849EC93439C9E22EB20D11D
07DA0F09EE9356D55B8D0D8555F1B0EC98C72863B376D3436E10DE2FB1AB9453
DADA019DCB64F6D059AB3A95B28B94435004C9A8BD3FB80E2B9DE0E330D03622
3AD965B4283E6DC880A2130185CDABC053C52693CE3F50557F524D7CCA9BE05B
FF9597ADF5D1C432C00C0B0D8EC2CA8436685B4BF3E2105B89FA6CC787B77637
248796C2F43872B3BFC8011159C22EDB7149AD8932360A88A223CC638BED257E
04908032ADA750F17279F7331189C322CB5ED9B66E502945BEB1EC68B1C7BCC0
2322EFD669C229B28CE1D0CBC0005FF967D0A4383E29538AFA13D41D484D739E
487D497DEAD8F661847A5D82D77D91219ACF666E565292384728E58E1A489054
8C3E34B413A6A550C499218E7FCF43694CBEAD016119CE85515F5EDAE3CD483B
A0F32743E7A189708AF0CB6FBAB22AC8F23604FFECE038C838472CA40ADEBF08
47AB1D450E07F9D51828D25DDCA679E3FAE54634A37AE1A5A778365C5A2C8A27
64085AC775AC132CCF27CA164C4721F67B63D52E388B17122F15E5DF391674CC
B6C9EDE307D79E390068970FE0AB210337558544E8CA59BD81BE2A2261F78F0C
0818078B97D227298B84B6450BDD689A1085FCFACCEEBECD2B3EDE3B6561AFC3
A88E05ED5D96C837B3386ABF1048FE5CC2AC87A20A2F4A4332E04AF4DAEC6833
0660124E1CB212491DDC3FB1BE0128C6BD451109B826A3F23AEBD548E162C8F5
00795C37140E10ED90518D2A7DA048AB78121E81C5237027289EC67D91F7299A
AC56823CD4BE926D0EE4E8CD05821DD89F3FA8506F268809EDFDDC647A3C41FD
3983A51C08D9C48CBADB1212E15060265B49FF437F270DCD43B21860B734DC01
663B0D93C5C6A15E55E227BAC4EF115AB6116957DA97DDFA62CF9AC0C97CBCBE
BA936014055D10434972C003AF6BF7798E9ACCE6349EBEC46D48139A8FC9005B
B2A10799477D1CEF3482DBF08A43A5DDBC57E1F272813DF7B7BA6C646A3174D8
876188AEE1C0B9BB4BE6F66BCEF2C09E14BCBC726979DE858914A95826CB2A8F
0F17773C8DCBF4EB5C69C1005B864AD5B757C661F15531E735F35AC2D8881540
047B466EDDA8610C578650E9B6EA14BE7B90AFB517178C9DFE59CE8B036E3B06
7B364E0F7447897BBF7B2461AB5288777DB575D01AA80CBF2A6EA578409FD6B6
4BF03A46E17307A879D563BDF674508971E73CD14B200DF449FB9D09F917E5CA
703C7E9395C19ED992688C38D5AB822DB77434BDC79A29F57AFA024E4521C755
D34B49654CA7AC01EC0550084F40A078FDC8E849A8639D82520AC5332EF9745D
634923AB6D69E941C9AD6125A56234A96C6AD33F56C836BB8ACDD07FCC210033
B0316FC13A50F6D110323B8E254352F257E3733A7CAB1F0C21D28BF894334254
229E7D4B63AE9FE8C66DFDBDD58BEEBAF5565EE90A4DDE01F338FB71E7ABE6EF
EB2A6172CBB0FB50132566DA2032C53F7A5B0E360136BA4C9CD37FB26769ADA2
129D5F14B9DB208D130BF5160D289564770D0A5EEBD939C3651A3B3D100EC7F4
58B977A9F37112DCFE34DDEC1B3DC5D54F473D67AA4E0B001530F5C1B8AEF5E3
2D7343E8E3BA1E4E2F9D8EEDBA09F0462AA8FA3A02C910C14CA858E82DA35191
74D386845193EBE4AE095AB5D606A31F7EEDF4F0298C9AE254619CFD825A559E
C882B95552C5215183E5FB51605BAA7948D6E51022CA3CBC729416976BF6A20B
BED57C6C0FD85C86DB60C5A94732BE0FCB9BFF90C4C783DD983579A30AAC1D58
756ACB344238EDD985C41FA9CB3C0EF588E026FDBD4AAA271DDEC0F7D5FD905C
59F0E7BC1EE0E3D5FED47B989162975370A4EE24C12429C8A21A0EE94F437DDE
B103FF247068EF9B9B43A951DC93BDAEF8452D109FB09BABE1DE6A9F210B5905
63EA94F930201A28F69DB7749DE522EC506EC6F9B2C43864D39B831D706919EC
065CD4A60ED52EF88C883E32850E2E11079CF61E9D66510A1A86F80719F3D684
436EDE35AD63A7E24D1FF6B3A5D9FD92C7D9C43A8255D0B63CD274CBAADA1979
7B2A3AAC758995A7355F79D06964067B2C7B74316AD3CFA839A3F2726AFF3A2E
092658E4EAE672C6AF953BF4821182D7A3485EB66391B6C8D23B7B1E1C778CAB
39F889A684F409BD672C3E6A26B4F5D239B975287260E0FAE00E1369F7ABE64B
951812CE620596CC91711D12A4155E5D1DCFDE9F4ECD69FD3024925621AC4EE5
80A496B1062FDB354D0361A3054FAD23A4FEC8948DC1EF163019E604B15ACE59
F9353871D9AA56B6AA8C7DDCC341E0DD06F394C35AFF997E06688D162C7FA895
DCCBD8276620B10E6C7E03FEA0F8B87FDC6F26F129B23CA3D345E26F3F7182BD
DAA58BB7B0A462DF5100C557358B8B66D23136C74DC047594AC441B7F6830D67
71F150299030DC7F996D7AE548B1E1B9EC45589B444FC797737012AAB970DBFD
0E97DB7DB969C07E70F4D2F5C6D7F44664C00B6ED73306425E913F25E79B7CE6
E98897122200398D64538921DACDAD6DA564240DBB494670FC1804D241E14CEF
CA03915F269B7B231F5D9B1F61DF7CB03421C5F4649CFAD32B83873EBC8C23AF
F4F13A96F3D9F1762CC76DD66D2B1C6378EBA79DF5CB0D5BDDA62504A20E6DC7
B0BB982F75ACF33109F8AE7ADE4954D0B1E18022FC5B5BA2F0E744ACCF23EAB3
C9E0437A2F11AADC452F3A2379EE0E65314F93025CF98030242B346868876A4C
F91C45816B9AC1146B1BB7AAA74FF92F4273B5DCAFFBC44BC099FB010E66C022
A1F8CEC627C3F54261E6B24DC4B8121EC2C5D4A3DBDD054ED20286FD9F694015
9CBCA05A698739E06AD7A82190FC0D137C29B51B30154E150FDEB16340AFF044
845F16B02C2735EAA1A9224661EA1929C604F9F239ADDB4D1DA9E54AAA3C2158
D42BF134AC514A3B200ED19FA308EF28E740D9982D87268F54AEB03939D61D55
6080A95A34025DD68C136ADADAC539167B655DE3EBFA84CCF6272DF6248F174C
D9AF10C276112F276BD184CC86A679A862AE11292BDDDF3D7295D522269A5896
1342FEE85EA941CAC420FAEEF05D837BC85CE181D328168D3606BBAF592D3388
58F2F85B3D51B967481DDB98793009F331B3EBFF72D98E1B683E9A691462E930
D817E7072D80C549E02CA7644DAE010536B0D6D72D3EBD3C54FDC1061985BFC8
C13F36F2A0B60F82ED1C7F608CCF232FC7B52721D44F13761959249E10508177
B1FF8B21E21EA7804FA50EF1BEBA5095045ABA7952457E62E4081D568FCF2917
E860A5399E2AB8705C835C93BE5FA7CB511028DA357F0E30D9AB91D1F73B6AE9
F49AF2051EB3AAD26D2D81FB0531381F8800FC7ABC5436137CB6E6DCBC2D08D6
4BDFC3240507494F7F10B401C9A267139EE51515D2BA0D44855014654D1A999C
AD1A5E9DDC982847484BA1FAB4EEA28220CB26778A212CC72827BCA8AE90301A
28BA4D14E7FACE24737C044BBA55138B436EAFCAF9102A25E5F047CC8473EC2A
C8E4B2CE9CDDF81C9B6EB5D7DA81F912531205130061A658110F84682B19C379
9784C1394A7F95FA260EA13D49E9EA45A2ED6C77763127B0725900DD92FEAB15
171D2A4C27736C9E61DB7F0FCC062D4E32B9D21CB37C994A65531F3E2F1438FF
2C98CFBED9D1B87A8DC71DD68B5B06F28D71D53750ED0F7B30F268BA2559C0B2
578D27ABF7986DB2B81B6BAF0E22877388980DA2201977AE85AB20E721E0DB58
AE80344C25C143C0106529251614B9361029950EB84DA4A1BDB0B4906AF58FC9
0E924BA57C647A6DFCBE5BF8E809733792AB4B266A5ECDBDFF5C2781E383DC7C
18994FF41C32E729613A1B4BC0D6AB383EF2F8EC3B0EA1A45820DF1B748AD5D3
1CDC27A23CFC07445D01E8A8D1E81DFFA64D5A505BA5F29CF1FDB8EDEB48313A
7572506B0535F4533105DA4D58480F968810CC4FE4CF3FB8E45859B54C5D7D4C
104D6151E62EEFCBB9484C98B65735F3BAA0D07216D7143A9DE0609E920B2957
0A42F1A0B83CB645B5DEF45696C589BC74CA556158DA32EAD64629BDED75ACCD
B798809B5F2254D8267FC364DCE291E8AD7A283205B517EB0CD00A3DD8E93C9C
51B054DEBB3839E7CE5246EE90BDBFBA0CAB505015D50735AEA78801DFF16D0C
5CB999236E0BDFE581B564A1A709DD2B46CE16840622483DD5B0CA1FC36989C5
0795131449E34116A99DECF148E7EA4CC098FEFF8FC40A6812C4230B0548988F
55BD73194F39825B910F6767843BB231CE87042576D9FDE8353927FF20406E7E
21859EBEE15470C47904DE9A4F6B520C1ED4EB1C67E7E16CEA45C7A70000B2D4
9835C34DE75CAF4932693BCE009A5805F20E19C2F050BA73D021C39EA26F677C
972818BF8C87A88DDEC17CF4BD5B6DCC5F7E835C3CE7D4454AAB91090C876B04
8BEE546DCA7F12728575512EC4A5C321BFEA9107607477B471844EDDFBE24126
D4B28B932406BA58CF58ED4B4AAECB28AB5E1CC4FFC422917E243C440FA84D92
0B62800559760771873D48F813C093D52026755C60637229781D1E47E62384F4
3D892585597CB66F5CCF5CBCF3E7D363C7296984A2980195E373EAF1B7B910D7
8DA4B2C02D360678126BC086FF6FFF378E0AAA0718A6975F16818D99B6F3E211
E760F8C31A12F21A8962CC7320B671273D0BF3A3C7921F473013C85B689D316D
3D35067C026677BDAAA73476CC26A3AFDD52CB57782CE9FEA06A0A30CEBD2157
6E6C1BAFA50300B13B7D57BAF71C49C5E84D13998BBDCAAEF26BB0801DB72A2B
C2BE45B1E8365FB8E75BF46534F5B8BACF3D7E4B538D56198355E8F2FA3DA1D6
25F2D12E32F9A2337A401C7690499871698EAB87F1C63E05022E797DEEB1AADE
ACC537C5F65D8A6B0AB65A59291F3A4C15CA1922B99C00E7F2AB9024484DA31C
12FC14836F61AE6633C7B772E7DF770FC0A01694B2C0CC18B3A8ECBD2FF39884
A5518C5747AA8D8CF6660A76C929E5680E005E0BC6E3F1E0E4666ABFAB1BCA3E
C75326188E2D3501AFD14FA0E75A402A26F85854113E102AB81806F6D5ACA40C
C18E3C64077DED2BF90FC4069F7AD811334239AE2A7C754AD9D987DEA4536887
AEC5EEF17F027F201CB939B592CF08B3DE2FFCE2665F6E24FD0636EA28FCDFFC
F3096D0E57910ECEC493223A64804E46E28B5870D74634CBF42718BFC37FB304
D8750084BC335950BB9D7140E82DDE34AB3DF79658A3EBA61D6A05C23B231A6B
1EA68BECBE1A468756DD8AB133AC13C0E23E4246E8ADA42A86C1B02C23B05B4E
492CED98E91CDD8E76A9AC4A422E8775C0EE79B627713588BB8FC5EBB97990AB
37BC829FA6CE8505761C8C4909E26B94ADDB23EE1F24C935CC08149BD21A8A6E
4A8774F5C49DECD2A4B570E70B8E9D715760FF4A66260FB27CF98EC28D2CE3FA
5D020948FA8E425100DAB13CF815BAB3EB5C6ECA50DE6B5A3599069ACF6CBA71
2F017DE4183F24AC1A9AF7B50407E9492E58C1BC7A1C7A243478DF17D01A7179
281462B1D39628F30DEE22608F976DFE83196161C4BC103A6321DB985A72ED36
6257498B8AC0C462253E8BC9EDD1195D91EE42DD794B66E4DD3B35BF99893789
063BF7B01D5F186B291585D0EF50FC3859C0CCD704BF425C64379E8F07D1B65B
2908E321283534F91CFE4A015CD40CE908BE2CE1AA067D03F4C29E1240F90533
E281EEEDCC3F5E4DE80BCCDE38E69B9CF025A82867C81B23EE5C520C6D50720D
60D5E4E90BDE98DA5E4D2BC78ED4EBA41C83C1D5DA8109D2A0AAB5337B999E29
0BB4078ED610795231E3FE9BE11E9A1D4BC8F03084DBC222062695EBC2322303
F2F23AA2DB97035A82372EE5B315A29C309EBBDEC6FE4167ADF08FC4640C3CF3
E6698EE25EF3B25B52F4C6636445610F743DE3ADCF4CE6147FF7EA5D7CE67F17
3819BABE5F350CA977EE307278A58B45EE508ABB928BBC60CCF7B7719863662F
4B67DAC7ABCD95D00D6EC3697634041E76D28A329C32C0E47C2233BB26CA5686
A2D16595D9D43C3ABFB90D56AD6C3797497B87DEE1289FFD2FF2ABCC0CF2914C
FA521AF185A396D56DA9A635B4F044C1C88BF1A9550F9D0ECC4166F0BE707884
A0B8DCC81FF62EA84BE02E234EBAB9C299FA31AF5699802472A1A66B670B9002
7C8229A1C603286913248D02EA353EA8344E4028AA3A3901F3F029C2A2FD48E4
D3B3C03BF7B08C87D716DCFB6FAFBE018716169DEB4EEDFD30F23BB5AF15E5C3
18EC2258D51989B112889DD3B16E3C881BE6261468AE2161179F152DA40388DB
AFBD05E330D6ADCF35E7888916AAAFB633E99510EAA34D054DCFE8CE8A5DC081
2E2538994C7E844FB2C017C88E478F1D81C4682604F6C11BFFA7B0D7AE938062
75CF17BFDC898870B512A63CCEF266295BE92A624B3232F6DA2048D55E4C56DB
BF466E99C99DAD23076683394F1BCB4C40921CCA76615015C88367108E9EA698
DEF3FCFB65365905FF0FD0BA77070BC4F011803F27BE11CFF48C5A15ACFC08FB
DCD8D63445AF35AEED71B50F2C1B112168D020E247D1F1D118CAF9E86095FF1D
20
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 16772797 13307382 1000 600 600 (bs)
@start /Fa 200[30 30 30 30 30 30 30 49[{}7 49.8132 /CMR6
rf /Fb 136[55 119[{}1 74.7198 /CMMI9 rf /Fc 105[29 28[29
4[16 23 19 2[29 29 45 16 29 1[16 29 2[26 1[26 1[26 12[36
5[42 4[19 7[42 18[15 1[15 10[19 33[{ TeXBase1Encoding ReEncodeFont }22
58.1154 /NimbusRomNo9L-Regu rf /Fd 139[19 23 26 3[32
8[26 32 2[29 97[{ TeXBase1Encoding ReEncodeFont }7 58.1154
/NimbusRomNo9L-Medi rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
% dvips-unknown
statusdict /setpageparams known { hsize vsize 0 1 statusdict begin {
setpageparams } stopped end } { true } ifelse { statusdict /setpage known
{ hsize vsize 1 statusdict begin { setpage } stopped pop end } if } if
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
-720 -576 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -720 -576 a -720 -576 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -720 -576 a -720
-576 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -720 -576 a -720 -576 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -720 -576 a -595 1062
a
 currentpoint currentpoint translate 1 1 scale neg exch neg exch translate
 -595 1062 a -568 243 a
tx@Dict begin { 142.93057 93.1782 } PutCoor PutBegin  end
 -568 243 a -626 261 a Fd(start)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 64.61867 66.43257 } PutCoor PutBegin  end
 -568 243 a -613 262 a Fc(The)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 113.39764 66.43257 } PutCoor PutBegin  end
 -568 243 a -589 263 a Fc(A)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 168.32904 66.43257 } PutCoor PutBegin  end
 -568 243 a -604 262 a Fc(No)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 222.66043 66.43257 } PutCoor PutBegin  end
 -568 243 a -578 262 a Fc(I)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 66.34834 70.8427 127.2372 90.1908
  /Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 114.71791 71.41188 135.7731
89.05244   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 165.36377 71.41188 149.4303
89.05244   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 221.70007 71.98106 158.53494
90.75998   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
-568 243 a
tx@Dict begin { 63.04486 38.549 } PutCoor PutBegin  end
 -568 243 a -602 259 a Fc(cat)-568 243 y
tx@Dict begin  PutEnd  end
 -568
243 a -568 243 a
tx@Dict begin { 111.87247 37.41107 } PutCoor PutBegin  end
 -568 243 a -575 242 a Fc(,)-568 243
y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 169.7561 38.549 } PutCoor PutBegin  end
 -568 243 a -575 246 a Fc(.)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 223.29602 37.41107 } PutCoor PutBegin  end
 -568 243 a -604 256 a Fc(am)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 64.02734 9.52708 } PutCoor PutBegin  end
 -568 243 a -607 262 a Fc(sits)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 111.08578 9.52708 } PutCoor PutBegin  end
 -568 243 a -644 262 a Fc(thanks)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 167.6713 8.38916 } PutCoor PutBegin  end
 -568 243 a -628 250 a Fc(sorry)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 223.16751 9.52708 } PutCoor PutBegin  end
 -568 243 a -613 263 a Fd(end)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 64.10333 -19.4944 } PutCoor PutBegin  end
 -568 243 a -647 256 a Fc(calmly)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 109.43643 -20.63275 } PutCoor PutBegin  end
 -568 243 a -575 246 a Fc(.)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 168.03555 -18.35648 } PutCoor PutBegin  end
 -568 243 a -578 262 a Fc(!)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 221.89587 -20.06357 } PutCoor PutBegin  end
 -568 243 a -583 250 a Fc(\226)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 63.91187 -47.37839 } PutCoor PutBegin  end
 -568 243 a -575 246 a Fc(.)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 109.92528 -47.37839 } PutCoor PutBegin  end
 -568 243 a -613 263 a Fd(end)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 167.96913 -47.37839 } PutCoor PutBegin  end
 -568 243 a -613 263 a Fd(end)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 222.46506 -48.51631 } PutCoor PutBegin  end
 -568 243 a -583 250 a Fc(\226)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 222.46506 -76.96906 } PutCoor PutBegin  end
 -568 243 a -583 250 a Fc(\226)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 167.26666 -77.53824 } PutCoor PutBegin  end
 -568 243 a -583 250 a Fc(\226)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 109.79199 -77.53824 } PutCoor PutBegin  end
 -568 243 a -583 250 a Fc(\226)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 63.83199 -75.26196 } PutCoor PutBegin  end
 -568 243 a -613 263 a Fd(end)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.64124 43.52832 111.30373
61.73805   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 112.44165 42.95914 166.50168
62.87598   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 169.9163 42.38995 169.9163
62.87598   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 223.40717 42.95914 223.40717
62.30724   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.64124 14.5064 64.64124 34.42323
  /Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 110.16537 13.36847 110.16537
33.28531   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 168.77795 15.07558 115.85583
33.85449   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 222.83842 16.21349 170.48549
34.9924   /Lineto /lineto load def 0  setlinejoin false  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.64124 -15.65343 64.64124
4.26338   /Lineto /lineto load def 0  setlinejoin false  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 110.16537 -15.65343 110.16537
4.26338   /Lineto /lineto load def 0  setlinejoin false  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 167.07086 -13.37715 116.425
3.69421   /Lineto /lineto load def 0  setlinejoin false  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 222.26926 -15.08426 222.26926
4.83257   /Lineto /lineto load def 0  setlinejoin false  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   4.55254 0
0 add  DotLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 110.16537 -44.10617 110.16537
-24.18935   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 168.77795 -43.537 168.77795
-23.62016   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.64124 -45.2441 64.64124
-25.32726   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 64.64124 -70.85182 64.64124
-50.93498   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 110.16537 -73.1281 110.16537
-53.21126   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   4.55254 0
0 add  DotLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 167.64003 -73.69684 167.64003
-53.78   /Lineto /lineto load def 0  setlinejoin false  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   4.55254 0
0 add  DotLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 222.26926 -42.96826 222.26926
-23.05098   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   4.55254 0
0 add  DotLine  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.56917 SLW 0  setgray  /ArrowA { moveto } def
/ArrowB { } def /ArrowInside { } def  [ 222.83842 -71.98975 222.83842
-52.0729   /Lineto /lineto load def 0  setlinejoin false  NArray n
0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 1.5 2.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.56917 SLW 0  setgray  1. .setopacityalpha   4.55254 0
0 add  DotLine  grestore end
 
@endspecial -568 243 a
tx@Dict begin { 14.56413 93.03581 } PutCoor PutBegin  end
 -568
243 a -613 255 a Fb(w)-558 263 y Fa(1)-568 243 y
tx@Dict begin  PutEnd  end
 -568
243 a -568 243 a
tx@Dict begin { 14.56413 38.4066 } PutCoor PutBegin  end
 -568 243 a -613 255 a Fb(w)-558 263
y Fa(3)-568 243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 14.56413 -19.06763 } PutCoor PutBegin  end
 -568 243 a -613
255 a Fb(w)-558 263 y Fa(5)-568 243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568
243 a
tx@Dict begin { 14.56413 9.95386 } PutCoor PutBegin  end
 -568 243 a -613 255 a Fb(w)-558 263 y Fa(4)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 14.56413 -74.266 } PutCoor PutBegin  end
 -568 243 a -613 255 a Fb(w)-558
263 y Fa(7)-568 243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 14.56413 -46.95161 } PutCoor PutBegin  end
 -568 243
a -613 255 a Fb(w)-558 263 y Fa(6)-568 243 y
tx@Dict begin  PutEnd  end
 -568 243
a -568 243 a
tx@Dict begin { 14.56413 66.85934 } PutCoor PutBegin  end
 -568 243 a -613 255 a Fb(w)-558 263 y Fa(2)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 64.30782 -93.4717 } PutCoor PutBegin  end
 -568 243 a -768 256 a Fc(A)15
b(cat)f(sits)g(calmly)l(.)-568 243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568
243 a
tx@Dict begin { 111.7483 -93.4717 } PutCoor PutBegin  end
 -568 243 a -701 258 a Fc(No,)g(thanks.)-568 243
y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 169.38274 -93.4717 } PutCoor PutBegin  end
 -568 243 a -703 258 a Fc(No,)g(thanks!)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -568 243 a
tx@Dict begin { 225.27448 -92.90253 } PutCoor PutBegin  end
 -568 243 a -611 262 a Fc(No.)-568
243 y
tx@Dict begin  PutEnd  end
 -568 243 a -595 1062 a
 currentpoint currentpoint translate 1 1 div 1 1 div scale neg exch
neg exch translate
 -595 1062 a 0 TeXcolorgray
0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
